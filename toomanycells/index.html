
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Spectral clustering">
      
      
        <meta name="author" content="JRR3">
      
      
        <link rel="canonical" href="https://JRR3.github.io/toomanycells/toomanycells/">
      
      
        <link rel="prev" href="../examples/intro/">
      
      
        <link rel="next" href="../common/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.30">
    
    
      
        <title>toomanycells module - toomanycells</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.3cba04c6.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Google+Sans:300,300i,400,400i,700,700i%7CRegular:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Google Sans";--md-code-font:"Regular"}</style>
      
    
    
      <link rel="stylesheet" href="../css/timeago.css">
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#toomanycells-module" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="toomanycells" class="md-header__button md-logo" aria-label="toomanycells" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            toomanycells
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              toomanycells module
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/JRR3/toomanycells" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="toomanycells" class="md-nav__button md-logo" aria-label="toomanycells" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    toomanycells
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/JRR3/toomanycells" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../installation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Installation
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../usage/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Usage
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Contributing
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../faq/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FAQ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Changelog
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/JRR3/toomanycells/issues" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Report Issues
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Examples
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/intro/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Intro
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    API Reference
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            API Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    toomanycells module
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    toomanycells module
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#toomanycells.toomanycells" class="md-nav__link">
    <span class="md-ellipsis">
      toomanycells.toomanycells
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells" class="md-nav__link">
    <span class="md-ellipsis">
      TooManyCells
    </span>
  </a>
  
    <nav class="md-nav" aria-label="TooManyCells">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.check_if_cells_belong_to_group" class="md-nav__link">
    <span class="md-ellipsis">
      check_if_cells_belong_to_group()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.compute_partition_for_gen" class="md-nav__link">
    <span class="md-ellipsis">
      compute_partition_for_gen()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.compute_partition_for_sp" class="md-nav__link">
    <span class="md-ellipsis">
      compute_partition_for_sp()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.convert_graph_to_json" class="md-nav__link">
    <span class="md-ellipsis">
      convert_graph_to_json()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.convert_mm_from_source_to_anndata" class="md-nav__link">
    <span class="md-ellipsis">
      convert_mm_from_source_to_anndata()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.create_data_for_tmci" class="md-nav__link">
    <span class="md-ellipsis">
      create_data_for_tmci()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.estimate_n_of_iterations" class="md-nav__link">
    <span class="md-ellipsis">
      estimate_n_of_iterations()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.generate_cell_annotation_file" class="md-nav__link">
    <span class="md-ellipsis">
      generate_cell_annotation_file()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.generate_matrix_from_signature_file" class="md-nav__link">
    <span class="md-ellipsis">
      generate_matrix_from_signature_file()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.get_path_from_node_x_to_node_y" class="md-nav__link">
    <span class="md-ellipsis">
      get_path_from_node_x_to_node_y()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.get_path_from_root_to_node" class="md-nav__link">
    <span class="md-ellipsis">
      get_path_from_root_to_node()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.load_cluster_info" class="md-nav__link">
    <span class="md-ellipsis">
      load_cluster_info()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.load_graph" class="md-nav__link">
    <span class="md-ellipsis">
      load_graph()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.normalize_dense_rows" class="md-nav__link">
    <span class="md-ellipsis">
      normalize_dense_rows()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.normalize_sparse_rows" class="md-nav__link">
    <span class="md-ellipsis">
      normalize_sparse_rows()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.plot_expression_from_node_x_to_node_y" class="md-nav__link">
    <span class="md-ellipsis">
      plot_expression_from_node_x_to_node_y()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.reverse_path" class="md-nav__link">
    <span class="md-ellipsis">
      reverse_path()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.run_spectral_clustering" class="md-nav__link">
    <span class="md-ellipsis">
      run_spectral_clustering()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.store_outputs" class="md-nav__link">
    <span class="md-ellipsis">
      store_outputs()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.update_cell_annotations" class="md-nav__link">
    <span class="md-ellipsis">
      update_cell_annotations()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.visualize_with_tmc_interactive" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_with_tmc_interactive()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.write_cell_assignment_to_csv" class="md-nav__link">
    <span class="md-ellipsis">
      write_cell_assignment_to_csv()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.write_cluster_list_to_json" class="md-nav__link">
    <span class="md-ellipsis">
      write_cluster_list_to_json()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../common/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    common module
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#toomanycells.toomanycells" class="md-nav__link">
    <span class="md-ellipsis">
      toomanycells.toomanycells
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells" class="md-nav__link">
    <span class="md-ellipsis">
      TooManyCells
    </span>
  </a>
  
    <nav class="md-nav" aria-label="TooManyCells">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.check_if_cells_belong_to_group" class="md-nav__link">
    <span class="md-ellipsis">
      check_if_cells_belong_to_group()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.compute_partition_for_gen" class="md-nav__link">
    <span class="md-ellipsis">
      compute_partition_for_gen()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.compute_partition_for_sp" class="md-nav__link">
    <span class="md-ellipsis">
      compute_partition_for_sp()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.convert_graph_to_json" class="md-nav__link">
    <span class="md-ellipsis">
      convert_graph_to_json()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.convert_mm_from_source_to_anndata" class="md-nav__link">
    <span class="md-ellipsis">
      convert_mm_from_source_to_anndata()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.create_data_for_tmci" class="md-nav__link">
    <span class="md-ellipsis">
      create_data_for_tmci()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.estimate_n_of_iterations" class="md-nav__link">
    <span class="md-ellipsis">
      estimate_n_of_iterations()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.generate_cell_annotation_file" class="md-nav__link">
    <span class="md-ellipsis">
      generate_cell_annotation_file()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.generate_matrix_from_signature_file" class="md-nav__link">
    <span class="md-ellipsis">
      generate_matrix_from_signature_file()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.get_path_from_node_x_to_node_y" class="md-nav__link">
    <span class="md-ellipsis">
      get_path_from_node_x_to_node_y()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.get_path_from_root_to_node" class="md-nav__link">
    <span class="md-ellipsis">
      get_path_from_root_to_node()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.load_cluster_info" class="md-nav__link">
    <span class="md-ellipsis">
      load_cluster_info()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.load_graph" class="md-nav__link">
    <span class="md-ellipsis">
      load_graph()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.normalize_dense_rows" class="md-nav__link">
    <span class="md-ellipsis">
      normalize_dense_rows()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.normalize_sparse_rows" class="md-nav__link">
    <span class="md-ellipsis">
      normalize_sparse_rows()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.plot_expression_from_node_x_to_node_y" class="md-nav__link">
    <span class="md-ellipsis">
      plot_expression_from_node_x_to_node_y()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.reverse_path" class="md-nav__link">
    <span class="md-ellipsis">
      reverse_path()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.run_spectral_clustering" class="md-nav__link">
    <span class="md-ellipsis">
      run_spectral_clustering()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.store_outputs" class="md-nav__link">
    <span class="md-ellipsis">
      store_outputs()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.update_cell_annotations" class="md-nav__link">
    <span class="md-ellipsis">
      update_cell_annotations()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.visualize_with_tmc_interactive" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_with_tmc_interactive()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.write_cell_assignment_to_csv" class="md-nav__link">
    <span class="md-ellipsis">
      write_cell_assignment_to_csv()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toomanycells.toomanycells.TooManyCells.write_cluster_list_to_json" class="md-nav__link">
    <span class="md-ellipsis">
      write_cluster_list_to_json()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                



                  

  
  


<h1 id="toomanycells-module">toomanycells module<a class="headerlink" href="#toomanycells-module" title="Permanent link">&para;</a></h1>


  <div class="doc doc-object doc-module">

<a id="toomanycells.toomanycells"></a>
    <div class="doc doc-contents first">




  <div class="doc doc-children">








  <div class="doc doc-object doc-class">



<h2 id="toomanycells.toomanycells.TooManyCells" class="doc doc-heading">
        <code>
TooManyCells        </code>



<a href="#toomanycells.toomanycells.TooManyCells" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>This class focuses on one aspect of the original         Too-Many-Cells tool, the clustering.\ 
    Features such as normalization,         dimensionality reduction and many others can be         applied using functions from libraries like \ 
    Scanpy, or they can be implemented locally. This         implementation also allows the possibility of         new features with respect to the original         Too-Many-Cells. For example, imagine you want to         continue partitioning fibroblasts until you have         at most a given number of cells, even if the         modularity becomes negative, but for CD8+ T-cells         you do not want to have partitions with less         than 100 cells. This can be easily implemented         with a few conditions using the cell annotations         in the .obs data frame of the AnnData object.
With regards to visualization, we recommend         using the too-many-cells-interactive tool.         You can find it at:\ 
    https://github.com/schwartzlab-methods/        too-many-cells-interactive.git        Once installed, you can use the function         visualize_with_tmc_interactive() to         generate the visualization. You will need         path to the installation folder of         too-many-cells-interactive.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">TooManyCells</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class focuses on one aspect of the original \</span>
<span class="sd">        Too-Many-Cells tool, the clustering.\ </span>
<span class="sd">        Features such as normalization, \</span>
<span class="sd">        dimensionality reduction and many others can be \</span>
<span class="sd">        applied using functions from libraries like \ </span>
<span class="sd">        Scanpy, or they can be implemented locally. This \</span>
<span class="sd">        implementation also allows the possibility of \</span>
<span class="sd">        new features with respect to the original \</span>
<span class="sd">        Too-Many-Cells. For example, imagine you want to \</span>
<span class="sd">        continue partitioning fibroblasts until you have \</span>
<span class="sd">        at most a given number of cells, even if the \</span>
<span class="sd">        modularity becomes negative, but for CD8+ T-cells \</span>
<span class="sd">        you do not want to have partitions with less \</span>
<span class="sd">        than 100 cells. This can be easily implemented \</span>
<span class="sd">        with a few conditions using the cell annotations \</span>
<span class="sd">        in the .obs data frame of the AnnData object.\</span>

<span class="sd">    With regards to visualization, we recommend \</span>
<span class="sd">        using the too-many-cells-interactive tool. \</span>
<span class="sd">        You can find it at:\ </span>
<span class="sd">        https://github.com/schwartzlab-methods/\</span>
<span class="sd">        too-many-cells-interactive.git\</span>
<span class="sd">        Once installed, you can use the function \</span>
<span class="sd">        visualize_with_tmc_interactive() to \</span>
<span class="sd">        generate the visualization. You will need \</span>
<span class="sd">        path to the installation folder of \</span>
<span class="sd">        too-many-cells-interactive.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#=================================================</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="nb">input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">AnnData</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
            <span class="n">output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">input_is_matrix_market</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">use_full_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The constructor takes the following inputs.</span>

<span class="sd">        :param input: Path to input directory or \</span>
<span class="sd">                AnnData object.</span>
<span class="sd">        :param output: Path to output directory.</span>
<span class="sd">        :param input_is_matrix_market: If true, \</span>
<span class="sd">                the directory should contain a \</span>
<span class="sd">                .mtx file, a barcodes.tsv file \</span>
<span class="sd">                and a genes.tsv file.</span>

<span class="sd">        :return: a TooManyCells object.</span>
<span class="sd">        :rtype: :obj:`TooManyCells`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#We use a directed graph to enforce the parent</span>
        <span class="c1">#to child relation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">TooManyCells</span><span class="p">):</span>

            <span class="c1">#Clone the given TooManyCells object.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">S</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span> <span class="o">=</span> <span class="n">S</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.h5ad&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Elapsed time for loading: &#39;</span> <span class="o">+</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">input_is_matrix_market</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">convert_mm_from_source_to_anndata</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.h5ad&#39;</span><span class="p">):</span>
                            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
                            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
                            <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Elapsed time for &#39;</span> <span class="o">+</span>
                                   <span class="s1">&#39;loading: &#39;</span> <span class="o">+</span>
                                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
                            <span class="k">break</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">AnnData</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unexpected input type.&#39;</span><span class="p">)</span>

        <span class="c1">#If no output directory is provided,</span>
        <span class="c1">#we use the current working directory.</span>
        <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s2">&quot;tmc_outputs&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Outputs will be saved in: </span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="c1">#This column of the obs data frame indicates</span>
        <span class="c1">#the correspondence between a cell and the </span>
        <span class="c1">#leaf node of the spectral clustering tree.</span>
        <span class="n">sp_cluster</span> <span class="o">=</span> <span class="s2">&quot;sp_cluster&quot;</span>
        <span class="n">sp_path</span> <span class="o">=</span> <span class="s2">&quot;sp_path&quot;</span>
        <span class="k">if</span> <span class="n">sp_cluster</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">sp_cluster</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">sp_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">sp_path</span><span class="p">]</span>    <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">sp_cluster</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_index</span> <span class="o">=</span> <span class="n">t</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">sp_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_column_index</span> <span class="o">=</span> <span class="n">t</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">delta_clustering</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_n_iter</span>     <span class="o">=</span> <span class="mi">0</span>

        <span class="c1">#Create a copy to avoid direct modifications</span>
        <span class="c1">#of the original count matrix X.</span>
        <span class="c1">#Note that we are making sure that the </span>
        <span class="c1">#sparse matrix has the CSR format. This</span>
        <span class="c1">#is relevant when we normalize.</span>
        <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">):</span>
            <span class="c1">#Compute the density of the matrix</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">nnz</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1">#If more than 50% of the matrix is occupied,</span>
            <span class="c1">#we generate a dense version of the matrix.</span>
            <span class="n">sparse_threshold</span> <span class="o">=</span> <span class="mf">0.50</span>
            <span class="k">if</span> <span class="n">use_full_matrix</span> <span class="ow">or</span> <span class="n">sparse_threshold</span> <span class="o">&lt;</span> <span class="n">rho</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Using a dense representation&quot;</span> 
                       <span class="s2">&quot; of the count matrix.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Values will be converted to&quot;</span> 
                       <span class="s2">&quot; float32.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1">#Make sure we use a CSR format.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                                       <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                                       <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#The matrix is dense.</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The matrix is dense.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Values will be converted to&quot;</span> 
                   <span class="s2">&quot; float32.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_genes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too few observations (cells).&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>

        <span class="c1">#Location of the matrix data for TMCI</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_clustering_has_been_called</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells_to_be_eliminated</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;/home/javier/Documents/repos/too-many-cells-interactive&quot;</span>

        <span class="c1"># We use a deque to offer the possibility of breadth-</span>
        <span class="c1"># versus depth-first. Our current implementation</span>
        <span class="c1"># uses depth-first to be consistent with the </span>
        <span class="c1"># numbering scheme of TooManyCellsInteractive.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DQ</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>


        <span class="c1">#Map a node to the path in the</span>
        <span class="c1">#binary tree that connects the</span>
        <span class="c1">#root node to the given node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_to_path</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">#Map a node to a list of indices</span>
        <span class="c1">#that provide access to the JSON</span>
        <span class="c1">#structure.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_to_j_index</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">#the JSON structure representation</span>
        <span class="c1">#of the tree.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">MultiIndexList</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1">#The threshold for modularity to </span>
        <span class="c1">#accept a given partition of a set</span>
        <span class="c1">#of cells.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-9</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_twopi_cmd</span>   <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose_mode</span>    <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">normalize_sparse_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide each row of the count matrix by the \</span>
<span class="sd">            given norm. Note that this function \</span>
<span class="sd">            assumes that the matrix is in the \</span>
<span class="sd">            compressed sparse row format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Normalizing rows.&quot;</span><span class="p">)</span>


        <span class="c1">#It&#39;s just an alias.</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">getrow</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">nz</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">data</span>
            <span class="n">row_norm</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">nz</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">similarity_norm</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">nz</span> <span class="o">/</span> <span class="n">row_norm</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mat</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">mat</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">row</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">normalize_dense_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide each row of the count matrix by the \</span>
<span class="sd">            given norm. Note that this function \</span>
<span class="sd">            assumes that the matrix is dense.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Normalizing rows.&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">row</span><span class="p">,</span>
                                  <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">similarity_norm</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">modularity_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;_item&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;_significance&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;_distance&#39;</span><span class="p">:</span> <span class="n">Q</span><span class="p">}</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">cell_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_name</span><span class="p">,</span> <span class="n">cell_number</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;_barcode&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;unCell&#39;</span><span class="p">:</span> <span class="n">cell_name</span><span class="p">},</span>
                <span class="s1">&#39;_cellRow&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;unRow&#39;</span><span class="p">:</span> <span class="n">cell_number</span><span class="p">}}</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">cells_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rows</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
            <span class="n">cell_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_to_json</span><span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
            <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;_item&#39;</span><span class="p">:</span> <span class="n">L</span><span class="p">,</span>
                <span class="s1">&#39;_significance&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;_distance&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">estimate_n_of_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We assume a model of the form \</span>
<span class="sd">        number_of_iter = const * N^exponent \</span>
<span class="sd">        where N is the number of cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#Average number of cells per leaf node</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6681664297844971</span><span class="p">)</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="mf">0.86121348</span>
        <span class="c1">#exponent = 0.9</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">iter_estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span><span class="n">q2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">iter_estimates</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">print_message_before_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The first iterations are typically slow.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;However, they tend to become faster as &quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;the size of the partition becomes smaller.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Note that the number of iterations is&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;only an estimate.&quot;</span><span class="p">)</span>
    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">reverse_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function reverses the path from the root\</span>
<span class="sd">        node to the leaf node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reversed_p</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">reversed_p</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">run_spectral_clustering</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">shift_similarity_matrix</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">normalize_rows</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">similarity_function</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;cosine_sparse&quot;</span><span class="p">,</span>
            <span class="n">similarity_norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">similarity_power</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">similarity_gamma</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">use_eig_decomp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">use_tf_idf</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">tf_idf_norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">tf_idf_smooth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">svd_algorithm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;randomized&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the partitions of the \</span>
<span class="sd">                initial cell population and continues \</span>
<span class="sd">                until the modularity of the newly \</span>
<span class="sd">                created partitions is nonpositive.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">svd_algorithms</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;randomized&quot;</span><span class="p">,</span><span class="s2">&quot;arpack&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">svd_algorithm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">svd_algorithms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected SVD algorithm.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">similarity_norm</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected similarity norm.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">similarity_norm</span> <span class="o">=</span> <span class="n">similarity_norm</span>

        <span class="k">if</span> <span class="n">similarity_gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># gamma = 1 / (number of features)</span>
            <span class="n">similarity_gamma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">similarity_gamma</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected similarity gamma.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">similarity_power</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected similarity power.&quot;</span><span class="p">)</span>

        <span class="n">similarity_functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;cosine_sparse&quot;</span><span class="p">)</span>
        <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;cosine&quot;</span><span class="p">)</span>
        <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;neg_exp&quot;</span><span class="p">)</span>
        <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;laplacian&quot;</span><span class="p">)</span>
        <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span>
        <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;div_by_sum&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">similarity_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">similarity_functions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected similarity fun.&quot;</span><span class="p">)</span>


        <span class="c1">#In case the user wants to call this function again.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_clustering_has_been_called</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">#TF-IDF section</span>
        <span class="k">if</span> <span class="n">use_tf_idf</span><span class="p">:</span>

            <span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using inverse document frequency (IDF).&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">tf_idf_norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using term frequency normalization.&quot;</span><span class="p">)</span>
                <span class="n">tf_idf_norms</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;l2&quot;</span><span class="p">,</span><span class="s2">&quot;l1&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tf_idf_norm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tf_idf_norms</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected tf norm.&quot;</span><span class="p">)</span>

            <span class="n">tf_idf_obj</span> <span class="o">=</span> <span class="n">TfidfTransformer</span><span class="p">(</span>
                <span class="n">norm</span><span class="o">=</span><span class="n">tf_idf_norm</span><span class="p">,</span>
                <span class="n">smooth_idf</span><span class="o">=</span><span class="n">tf_idf_smooth</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">tf_idf_obj</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#If the matrix was originally dense</span>
                <span class="c1">#and the tf_idf function changed it</span>
                <span class="c1">#to sparse, then convert to dense.</span>
                <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

            <span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">-</span> <span class="n">t0</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Elapsed time for IDF build: &quot;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

        <span class="c1">#Normalization section</span>
        <span class="n">use_cos_sp</span> <span class="o">=</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine_sparse&quot;</span>
        <span class="n">use_dbs</span> <span class="o">=</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;div_by_sum&quot;</span>
        <span class="k">if</span> <span class="n">normalize_rows</span> <span class="ow">or</span> <span class="n">use_cos_sp</span> <span class="ow">or</span> <span class="n">use_dbs</span><span class="p">:</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">normalize_sparse_rows</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">normalize_dense_rows</span><span class="p">()</span>

            <span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">-</span> <span class="n">t0</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Elapsed time for normalization: &quot;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

        <span class="c1">#Similarity section.</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working with </span><span class="si">{</span><span class="n">similarity_function</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine_sparse&quot;</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">trunc_SVD</span> <span class="o">=</span> <span class="n">TruncatedSVD</span><span class="p">(</span>
                    <span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">n_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                    <span class="n">algorithm</span><span class="o">=</span><span class="n">svd_algorithm</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Use a similarity function different from</span>
            <span class="c1">#the cosine_sparse similarity function.</span>

            <span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building similarity matrix ...&quot;</span><span class="p">)</span>
            <span class="n">n_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">max_workers</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
            <span class="n">n_workers</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">:</span>
                <span class="k">if</span> <span class="mi">8</span> <span class="o">&lt;</span> <span class="n">max_workers</span><span class="p">:</span>
                    <span class="n">n_workers</span> <span class="o">=</span> <span class="mi">8</span>
            <span class="k">elif</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="mi">50000</span><span class="p">:</span>
                <span class="k">if</span> <span class="mi">16</span> <span class="o">&lt;</span> <span class="n">max_workers</span><span class="p">:</span>
                    <span class="n">n_workers</span> <span class="o">=</span> <span class="mi">16</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="mi">25</span> <span class="o">&lt;</span> <span class="n">max_workers</span><span class="p">:</span>
                    <span class="n">n_workers</span> <span class="o">=</span> <span class="mi">25</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using </span><span class="si">{</span><span class="n">n_workers</span><span class="si">=}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine_sparse&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine&quot;</span><span class="p">:</span>
            <span class="c1">#( x @ y ) / ( ||x|| * ||y|| )</span>
            <span class="k">def</span> <span class="nf">sim_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
                <span class="n">cos_sim</span> <span class="o">=</span> <span class="n">x</span> <span class="o">@</span> <span class="n">y</span>
                <span class="n">x_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">y_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">cos_sim</span> <span class="o">/=</span> <span class="p">(</span><span class="n">x_norm</span> <span class="o">*</span> <span class="n">y_norm</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">cos_sim</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">pairwise_kernels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                                        <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;cosine&quot;</span><span class="p">,</span>
                                        <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;neg_exp&quot;</span><span class="p">:</span>
            <span class="c1">#exp(-||x-y||^power * gamma)</span>
            <span class="k">def</span> <span class="nf">sim_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">similarity_norm</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">similarity_power</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">delta</span> <span class="o">*</span> <span class="n">similarity_gamma</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">pairwise_kernels</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="n">sim_fun</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;laplacian&quot;</span><span class="p">:</span>
            <span class="c1">#exp(-||x-y||^power * gamma)</span>
            <span class="k">def</span> <span class="nf">sim_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">delta</span> <span class="o">*</span> <span class="n">similarity_gamma</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">pairwise_kernels</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;laplacian&quot;</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_workers</span><span class="p">,</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">similarity_gamma</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
            <span class="c1">#exp(-||x-y||^power * gamma)</span>
            <span class="k">def</span> <span class="nf">sim_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">delta</span> <span class="o">*</span> <span class="n">similarity_gamma</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">pairwise_kernels</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;rbf&quot;</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_workers</span><span class="p">,</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">similarity_gamma</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;div_by_sum&quot;</span><span class="p">:</span>
            <span class="c1">#1 - ( ||x-y|| / (||x|| + ||y||) )^power</span>
            <span class="c1">#The rows should have been previously normalized.</span>
            <span class="k">def</span> <span class="nf">sim_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">similarity_norm</span><span class="p">)</span>
                <span class="n">x_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">similarity_norm</span><span class="p">)</span>
                <span class="n">y_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                    <span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">similarity_norm</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">/=</span> <span class="p">(</span><span class="n">x_norm</span> <span class="o">+</span> <span class="n">y_norm</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span>  <span class="mi">1</span> <span class="o">-</span> <span class="n">delta</span>
                <span class="k">return</span> <span class="n">value</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">similarity_norm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lp_norm</span> <span class="o">=</span> <span class="s2">&quot;l1&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">similarity_norm</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">lp_norm</span> <span class="o">=</span> <span class="s2">&quot;l2&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;Similarity norm should be 1 or 2.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                                        <span class="n">metric</span><span class="o">=</span><span class="n">lp_norm</span><span class="p">,</span>
                                        <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">0.5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">similarity_function</span> <span class="o">!=</span> <span class="s2">&quot;cosine_sparse&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">shift_similarity_matrix</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Similarity matrix will be shifted.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shift: </span><span class="si">{</span><span class="n">shift_similarity_matrix</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">+=</span> <span class="n">shift_similarity_matrix</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Similarity matrix has been built.&quot;</span><span class="p">)</span>
            <span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">-</span> <span class="n">t0</span>
            <span class="n">delta</span> <span class="o">/=</span> <span class="mi">60</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Elapsed time for similarity build: &quot;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> minutes.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">use_eig_decomp</span> <span class="o">=</span> <span class="n">use_eig_decomp</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>

        <span class="c1">#===========================================</span>
        <span class="c1">#=============Main=Loop=====================</span>
        <span class="c1">#===========================================</span>
        <span class="n">node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_counter</span>

        <span class="c1">#Initialize the array of cells to partition</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1">#Initialize the deque</span>
        <span class="c1"># self.DQ.append((rows, None))</span>
        <span class="c1"># self.DQ.append(rows)</span>

        <span class="c1">#Initialize the graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">))</span>

        <span class="c1">#Path to reach root node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_to_path</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

        <span class="c1">#Indices to reach root node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_to_j_index</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1">#Update the node counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1">#============STEP=1================Cluster(0)</span>

        <span class="n">p_node_id</span> <span class="o">=</span> <span class="n">node_id</span>

        <span class="k">if</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine_sparse&quot;</span><span class="p">:</span>
            <span class="n">Q</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_partition_for_sp</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Q</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_partition_for_gen</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="n">Q</span><span class="p">:</span>
            <span class="c1">#Modularity is above threshold, and</span>
            <span class="c1">#thus each partition will be </span>
            <span class="c1">#inserted into the deque.</span>

            <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modularity_to_json</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

            <span class="c1">#Update json index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c1"># self.J.append([[],[]])</span>
            <span class="c1"># j_index = (1,)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;Q&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span>

            <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">p_node_id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">DQ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Modularity is below threshold and </span>
            <span class="c1">#therefore this partition will not</span>
            <span class="c1">#be considered.</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;All cells belong&quot;</span> 
                    <span class="s2">&quot; to the same partition.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">max_n_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_n_of_iterations</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">print_message_before_clustering</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">max_n_iter</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="k">while</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DQ</span><span class="p">):</span>

                <span class="c1">#Get the rows corresponding to the</span>
                <span class="c1">#partition and the (parent) node</span>
                <span class="c1">#that produced such partition.</span>
                <span class="n">rows</span><span class="p">,</span> <span class="n">p_node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DQ</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                <span class="c1">#This id is for the new node.</span>
                <span class="n">node_id</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># For every cluster of cells that is popped</span>
                <span class="c1"># from the deque, we update the node_id. </span>
                <span class="c1"># If the cluster is further partitioned we </span>
                <span class="c1"># will store each partition but will not </span>
                <span class="c1"># assign node numbers. Node numbers will </span>
                <span class="c1"># only be assigned after being popped from </span>
                <span class="c1"># the deque.</span>

                <span class="c1"># We need to know the modularity to </span>
                <span class="c1"># determine if the node will </span>
                <span class="k">if</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine_sparse&quot;</span><span class="p">:</span>
                    <span class="n">Q</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_partition_for_sp</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Q</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_partition_for_gen</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

                <span class="c1"># If the parent node is 0, then the path is</span>
                <span class="c1"># &quot;0&quot;.</span>
                <span class="n">current_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_path</span><span class="p">[</span><span class="n">p_node_id</span><span class="p">]</span>

                <span class="c1">#Update path for the new node</span>
                <span class="n">new_path</span> <span class="o">=</span> <span class="n">current_path</span> 
                <span class="n">new_path</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">node_to_path</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="o">=</span><span class="n">new_path</span>

                <span class="c1"># If the parent node is 0, then j_index is</span>
                <span class="c1"># (1,)</span>
                <span class="n">j_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_j_index</span><span class="p">[</span><span class="n">p_node_id</span><span class="p">]</span>

                <span class="n">n_stored_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="c1">#Update the j_index. For example, if</span>
                <span class="c1">#j_index = (1,) and no blocks have been</span>
                <span class="c1">#stored, then the new j_index is (1,0).</span>
                <span class="c1">#Otherwise, it is (1,1).</span>
                <span class="n">j_index</span> <span class="o">+=</span> <span class="p">(</span><span class="n">n_stored_blocks</span><span class="p">,)</span>

                <span class="c1">#Include new node into the graph.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">))</span>

                <span class="c1">#Include new edge into the graph.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">p_node_id</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="n">Q</span><span class="p">:</span>
                    <span class="c1">#Modularity is above threshold, and</span>
                    <span class="c1">#thus each partition will be </span>
                    <span class="c1">#inserted into the deque.</span>

                    <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modularity_to_json</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="n">j_index</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

                    <span class="c1"># We only store the modularity of nodes</span>
                    <span class="c1"># whose modularity is above threshold.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;Q&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span>

                    <span class="c1"># Update the j_index for the newly </span>
                    <span class="c1"># created node. (1,0,1)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">node_to_j_index</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">j_index</span>

                    <span class="c1"># Append each partition to the deque.</span>
                    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                        <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">DQ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#Modularity is below threshold and </span>
                    <span class="c1">#therefore this partition will not</span>
                    <span class="c1">#be considered.</span>

                    <span class="c1">#Update the relation between a set of</span>
                    <span class="c1">#cells and the corresponding leaf node.</span>
                    <span class="c1">#Also include the path to reach that node.</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_index</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_id</span>

                    <span class="n">reversed_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_path</span><span class="p">(</span>
                        <span class="n">new_path</span><span class="p">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_column_index</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reversed_path</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

                    <span class="c1">#Update the JSON structure for </span>
                    <span class="c1">#a leaf node.</span>
                    <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells_to_json</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

            <span class="c1">#==============END OF WHILE==============</span>
            <span class="n">pbar</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">pbar</span><span class="o">.</span><span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_n_iter</span> <span class="o">=</span> <span class="n">pbar</span><span class="o">.</span><span class="n">n</span>
            <span class="n">pbar</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_clustering</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_clustering</span> <span class="o">/=</span> <span class="mi">60</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Elapsed time for clustering: &quot;</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_clustering</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> minutes.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">compute_partition_for_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="c1">#) -&gt; tuple[float, np.ndarray]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the partition of the given set\</span>
<span class="sd">            of cells. The rows input \</span>
<span class="sd">            contains the indices of the \</span>
<span class="sd">            rows we are to partition. \</span>
<span class="sd">            The algorithm computes a truncated \</span>
<span class="sd">            SVD and the corresponding modularity \</span>
<span class="sd">            of the newly created communities.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_mode</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;I was given: </span><span class="si">{</span><span class="n">rows</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">partition</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> 
        <span class="c1">#print(f&quot;Number of cells: {n_rows}&quot;)</span>

        <span class="c1">#If the number of rows is less than 3,</span>
        <span class="c1">#we keep the cluster as it is.</span>
        <span class="k">if</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">rows</span><span class="p">,:]</span>
        <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_rows</span><span class="p">)</span>
        <span class="n">partial_row_sums</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ones</span><span class="p">)</span>
        <span class="c1">#1^T @ B @ B^T @ 1 = (B^T @ 1)^T @ (B^T @ 1)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">partial_row_sums</span> <span class="o">@</span> <span class="n">partial_row_sums</span> <span class="o">-</span> <span class="n">n_rows</span>
        <span class="c1">#These are the row sums of the similarity matrix</span>
        <span class="n">row_sums</span> <span class="o">=</span> <span class="n">B</span> <span class="o">@</span> <span class="n">partial_row_sums</span>
        <span class="c1">#Check if we have negative entries before computing</span>
        <span class="c1">#the square root.</span>
        <span class="c1"># if  neg_row_sums or self.use_eig_decomp:</span>
        <span class="n">zero_row_sums_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">has_zero_row_sums</span> <span class="o">=</span> <span class="n">zero_row_sums_mask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="n">has_neg_row_sums</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_sums</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 

        <span class="k">if</span> <span class="n">has_zero_row_sums</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We have zero row sums.&quot;</span><span class="p">)</span>
            <span class="n">row_sums</span><span class="p">[</span><span class="n">zero_row_sums_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">has_neg_row_sums</span> <span class="ow">and</span> <span class="n">has_zero_row_sums</span><span class="p">:</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This matrix cannot be processed.&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;Cannot have negative and zero row sums.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

        <span class="k">if</span>  <span class="n">has_neg_row_sums</span><span class="p">:</span>
            <span class="c1">#This means we cannot use the fast approach</span>
            <span class="c1">#We&#39;ll have to build a dense representation</span>
            <span class="c1"># of the similarity matrix.</span>
            <span class="k">if</span> <span class="mi">5000</span> <span class="o">&lt;</span> <span class="n">n_rows</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The row sums are negative.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We will use a full eigen decomp.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The block size is </span><span class="si">{</span><span class="n">n_rows</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning ...&quot;</span><span class="p">)</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This operation is very expensive.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">B</span> <span class="o">@</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span>
            <span class="n">row_sums_mtx</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span>
            <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">row_sums_mtx</span> <span class="o">-</span> <span class="n">laplacian_mtx</span>

            <span class="c1">#This is a very expensive operation</span>
            <span class="c1">#since it computes all the eigenvectors.</span>
            <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">row_sums</span>
            <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">inv_row_sums</span><span class="p">)</span>
            <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">inv_row_sums</span> <span class="o">@</span> <span class="n">laplacian_mtx</span>
            <span class="n">eig_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">)</span>
            <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvalues</span>
            <span class="n">eig_vecs</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvectors</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)))</span>
            <span class="c1">#Get the index of the second smallest eigenvalue.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vecs</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="p">))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_eig_decomp</span> <span class="ow">or</span> <span class="n">has_zero_row_sums</span><span class="p">:</span>
            <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">B</span> <span class="o">@</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span>
            <span class="n">row_sums_mtx</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span>
            <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">row_sums_mtx</span> <span class="o">-</span> <span class="n">laplacian_mtx</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1">#if the row sums are negative, this </span>
                <span class="c1">#step could fail.</span>
                <span class="n">E_obj</span> <span class="o">=</span> <span class="n">Eigen_Hermitian</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">,</span>
                                        <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                        <span class="n">M</span><span class="o">=</span><span class="n">row_sums_mtx</span><span class="p">,</span>
                                        <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">which</span><span class="o">=</span><span class="s2">&quot;LM&quot;</span><span class="p">)</span>
                <span class="n">eigen_val_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">E_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1">#Identify the eigenvalue with the</span>
                <span class="c1">#largest magnitude.</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">eigen_val_abs</span><span class="p">)</span>
                <span class="c1">#Choose the eigenvector corresponding</span>
                <span class="c1"># to the eigenvalue with the </span>
                <span class="c1"># largest magnitude.</span>
                <span class="n">eigen_vectors</span> <span class="o">=</span> <span class="n">E_obj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">eigen_vectors</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1">#This is a very expensive operation</span>
                <span class="c1">#since it computes all the eigenvectors.</span>
                <span class="k">if</span> <span class="mi">5000</span> <span class="o">&lt;</span> <span class="n">n_rows</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We will use a full eigen decomp.&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The block size is </span><span class="si">{</span><span class="n">n_rows</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning ...&quot;</span><span class="p">)</span>
                    <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This operation is very expensive.&quot;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
                <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">row_sums</span>
                <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">inv_row_sums</span><span class="p">)</span>
                <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">inv_row_sums</span> <span class="o">@</span> <span class="n">laplacian_mtx</span>
                <span class="n">eig_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">)</span>
                <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvalues</span>
                <span class="n">eig_vecs</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvectors</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)))</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vecs</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="p">))</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#This is the fast approach.</span>
            <span class="c1">#It is fast in the sense that the </span>
            <span class="c1">#operations are faster if the matrix</span>
            <span class="c1">#is sparse, i.e., O(n) nonzero entries.</span>

            <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">D</span> <span class="o">@</span> <span class="n">B</span>
            <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trunc_SVD</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="n">singular_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trunc_SVD</span><span class="o">.</span><span class="n">singular_values_</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">singular_values</span><span class="p">)</span>
            <span class="c1">#Get the singular vector corresponding to the</span>
            <span class="c1">#second largest singular value.</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>


        <span class="n">mask_c1</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">W</span>
        <span class="n">mask_c2</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask_c1</span>

        <span class="c1">#If one partition has all the elements</span>
        <span class="c1">#then return with Q = 0.</span>
        <span class="k">if</span> <span class="n">mask_c1</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span> <span class="n">mask_c2</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">mask_c1</span><span class="p">,</span> <span class="n">mask_c2</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">:</span>
            <span class="n">n_rows_msk</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">partition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">ones_msk</span> <span class="o">=</span> <span class="n">ones</span> <span class="o">*</span> <span class="n">mask</span>
            <span class="n">row_sums_msk</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ones_msk</span><span class="p">)</span>
            <span class="n">O_c</span> <span class="o">=</span> <span class="n">row_sums_msk</span> <span class="o">@</span> <span class="n">row_sums_msk</span> <span class="o">-</span> <span class="n">n_rows_msk</span>
            <span class="n">L_c</span> <span class="o">=</span> <span class="n">ones_msk</span> <span class="o">@</span> <span class="n">row_sums</span>  <span class="o">-</span> <span class="n">n_rows_msk</span>
            <span class="n">Q</span> <span class="o">+=</span> <span class="n">O_c</span> <span class="o">/</span> <span class="n">L</span> <span class="o">-</span> <span class="p">(</span><span class="n">L_c</span> <span class="o">/</span> <span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_mode</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Q</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;I found: </span><span class="si">{</span><span class="n">partition</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;===========================&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">compute_partition_for_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="c1">#) -&gt; tuple[float, np.ndarray]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the partition of the given set\</span>
<span class="sd">            of cells. The rows input \</span>
<span class="sd">            contains the indices of the \</span>
<span class="sd">            rows we are to partition. \</span>
<span class="sd">            The algorithm computes a truncated \</span>
<span class="sd">            SVD and the corresponding modularity \</span>
<span class="sd">            of the newly created communities.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_mode</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;I was given: </span><span class="si">{</span><span class="n">rows</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">partition</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> 
        <span class="c1">#print(f&quot;Number of cells: {n_rows}&quot;)</span>

        <span class="c1">#If the number of rows is less than 3,</span>
        <span class="c1">#we keep the cluster as it is.</span>
        <span class="k">if</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">rows</span><span class="p">)]</span>
        <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_rows</span><span class="p">)</span>
        <span class="n">row_sums</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ones</span><span class="p">)</span>
        <span class="n">row_sums_mtx</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span>
        <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">row_sums_mtx</span> <span class="o">-</span> <span class="n">S</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_rows</span>

        <span class="n">zero_row_sums_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">has_zero_row_sums</span> <span class="o">=</span> <span class="n">zero_row_sums_mask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="n">has_neg_row_sums</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_sums</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 

        <span class="k">if</span> <span class="n">has_zero_row_sums</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We have zero row sums.&quot;</span><span class="p">)</span>
            <span class="n">row_sums</span><span class="p">[</span><span class="n">zero_row_sums_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">has_neg_row_sums</span> <span class="ow">and</span> <span class="n">has_zero_row_sums</span><span class="p">:</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This matrix cannot be processed.&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;Cannot have negative and zero row sums.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">has_neg_row_sums</span><span class="p">:</span>
            <span class="c1">#This is a very expensive operation</span>
            <span class="c1">#since it computes all the eigenvectors.</span>
            <span class="k">if</span> <span class="mi">5000</span> <span class="o">&lt;</span> <span class="n">n_rows</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The row sums are negative.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We will use a full eigen decomp.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The block size is </span><span class="si">{</span><span class="n">n_rows</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning ...&quot;</span><span class="p">)</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This operation is very expensive.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">row_sums</span>
            <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">inv_row_sums</span><span class="p">)</span>
            <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">inv_row_sums</span> <span class="o">@</span> <span class="n">laplacian_mtx</span>
            <span class="n">eig_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">)</span>
            <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvalues</span>
            <span class="n">eig_vecs</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvectors</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)))</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vecs</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Nonnegative row sums.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">E_obj</span> <span class="o">=</span> <span class="n">Eigen_Hermitian</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">,</span>
                                        <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                        <span class="n">M</span><span class="o">=</span><span class="n">row_sums_mtx</span><span class="p">,</span>
                                        <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">which</span><span class="o">=</span><span class="s2">&quot;LM&quot;</span><span class="p">)</span>
                <span class="n">eigen_val_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">E_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1">#Identify the eigenvalue with the</span>
                <span class="c1">#largest magnitude.</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">eigen_val_abs</span><span class="p">)</span>
                <span class="c1">#Choose the eigenvector corresponding</span>
                <span class="c1"># to the eigenvalue with the </span>
                <span class="c1"># largest magnitude.</span>
                <span class="n">eigen_vectors</span> <span class="o">=</span> <span class="n">E_obj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">eigen_vectors</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="c1">#This is a very expensive operation</span>
                <span class="c1">#since it computes all the eigenvectors.</span>
                <span class="k">if</span> <span class="mi">5000</span> <span class="o">&lt;</span> <span class="n">n_rows</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We will use a full eigen decomp.&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The block size is </span><span class="si">{</span><span class="n">n_rows</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning ...&quot;</span><span class="p">)</span>
                    <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This operation is very expensive.&quot;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
                <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">row_sums</span>
                <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">inv_row_sums</span><span class="p">)</span>
                <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">inv_row_sums</span> <span class="o">@</span> <span class="n">laplacian_mtx</span>
                <span class="n">eig_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">)</span>
                <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvalues</span>
                <span class="n">eig_vecs</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvectors</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)))</span>
                <span class="c1">#Get the index of the second smallest </span>
                <span class="c1">#eigenvalue.</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vecs</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="p">))</span>


        <span class="n">mask_c1</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">W</span>
        <span class="n">mask_c2</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask_c1</span>

        <span class="c1">#If one partition has all the elements</span>
        <span class="c1">#then return with Q = 0.</span>
        <span class="k">if</span> <span class="n">mask_c1</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span> <span class="n">mask_c2</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">mask_c1</span><span class="p">,</span> <span class="n">mask_c2</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">:</span>
            <span class="n">n_rows_msk</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">partition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">ones_msk</span> <span class="o">=</span> <span class="n">ones</span> <span class="o">*</span> <span class="n">mask</span>
            <span class="n">row_sums_msk</span> <span class="o">=</span> <span class="n">S</span> <span class="o">@</span> <span class="n">ones_msk</span>
            <span class="n">O_c</span> <span class="o">=</span> <span class="n">ones_msk</span> <span class="o">@</span> <span class="n">row_sums_msk</span> <span class="o">-</span> <span class="n">n_rows_msk</span>
            <span class="n">L_c</span> <span class="o">=</span> <span class="n">ones_msk</span> <span class="o">@</span> <span class="n">row_sums</span>  <span class="o">-</span> <span class="n">n_rows_msk</span>
            <span class="n">Q</span> <span class="o">+=</span> <span class="n">O_c</span> <span class="o">/</span> <span class="n">L</span> <span class="o">-</span> <span class="p">(</span><span class="n">L_c</span> <span class="o">/</span> <span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_mode</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Q</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;I found: </span><span class="si">{</span><span class="n">partition</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;===========================&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">store_outputs</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the outputs and plot the branching tree.</span>

<span class="sd">        File outputs:</span>

<span class="sd">        cluster_list.json: The json file containing a list </span>
<span class="sd">        of clusters. </span>

<span class="sd">        cluster_tree.json: The json file containing the </span>
<span class="sd">        output tree in a recursive format.</span>

<span class="sd">        graph.dot: A dot file of the tree. It includes the </span>
<span class="sd">        modularity and the size.</span>

<span class="sd">        node_info.csv: Size and modularity of each node.</span>

<span class="sd">        clusters.csv: The cluster membership for each cell.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>


        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;graph.dot&#39;</span>
        <span class="n">dot_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

        <span class="n">nx</span><span class="o">.</span><span class="n">nx_agraph</span><span class="o">.</span><span class="n">write_dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">dot_fname</span><span class="p">)</span>
        <span class="c1">#Write cell to node data frame.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_cell_assignment_to_csv</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_graph_to_json</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_cluster_list_to_json</span><span class="p">()</span>

        <span class="c1">#Store the cell annotations in the output folder.</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ann_col</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cell_ann_col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generate_cell_annotation_file</span><span class="p">(</span>
                    <span class="n">cell_ann_col</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;Annotation column does not exists.&quot;</span>
                <span class="c1">#raise ValueError(txt)</span>

        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>

        <span class="c1">#Number of cells for each node</span>
        <span class="n">size_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#Modularity for each node</span>
        <span class="n">Q_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#Node label</span>
        <span class="n">node_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">size_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s1">&#39;Q&#39;</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                <span class="n">Q_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;Q&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Q_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1">#Write node information to CSV</span>
        <span class="n">D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_list</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span><span class="n">size_list</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">:</span><span class="n">Q_list</span><span class="p">}</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;node_info.csv&#39;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_twopi_cmd</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_radial_tree_from_dot_file</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Elapsed time for storing outputs: &#39;</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>


    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">convert_mm_from_source_to_anndata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function reads the matrix.mtx file \</span>
<span class="sd">                located at the source directory.\</span>
<span class="sd">                Since we assume that the matrix \</span>
<span class="sd">                has the format genes x cells, we\</span>
<span class="sd">                transpose the matrix, then \</span>
<span class="sd">                convert it to the CSR format \</span>
<span class="sd">                and then into an AnnData object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading data from .mtx file.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Note that we assume the format:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;genes=rows and cells=columns.&#39;</span><span class="p">)</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.mtx&#39;</span><span class="p">):</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">f</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;.mtx file not found.&#39;</span><span class="p">)</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mmread</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="c1">#Remember that the input matrix has</span>
        <span class="c1">#genes for rows and cells for columns.</span>
        <span class="c1">#Thus, just transpose.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;barcodes.tsv&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">df_barcodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
                <span class="n">fname</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">barcodes</span> <span class="o">=</span> <span class="n">df_barcodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;genes.tsv&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">df_genes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
                <span class="n">fname</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">genes</span> <span class="o">=</span> <span class="n">df_genes</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">AnnData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs_names</span> <span class="o">=</span> <span class="n">barcodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="n">genes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Elapsed time for loading: &#39;</span> <span class="o">+</span> 
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">write_cell_assignment_to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function creates a CSV file that indicates \</span>
<span class="sd">            the assignment of each cell to a specific \</span>
<span class="sd">            cluster. The first column is the cell id, \</span>
<span class="sd">            the second column is the cluster id, and \</span>
<span class="sd">            the third column is the path from the root \</span>
<span class="sd">            node to the given node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;clusters.csv&#39;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sp_cluster&#39;</span><span class="p">,</span><span class="s1">&#39;sp_path&#39;</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">labels</span><span class="p">]</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;sp_cluster&#39;</span><span class="p">:</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;sp_path&#39;</span><span class="p">:</span><span class="s1">&#39;path&#39;</span><span class="p">})</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">write_cluster_list_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function creates a JSON file that indicates \</span>
<span class="sd">            the assignment of each cell to a specific \</span>
<span class="sd">            cluster. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;cluster_list.json&#39;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">master_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">relevant_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">,</span> <span class="s2">&quot;sp_path&quot;</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">relevant_cols</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="s2">&quot;cell&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">,</span><span class="s2">&quot;cell&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">cluster</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">]</span>
            <span class="n">path_str</span><span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;sp_path&quot;</span><span class="p">]</span>
            <span class="n">cell</span>    <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;cell&quot;</span><span class="p">]</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">path_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="n">list_of_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">sub_dict_1</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;unCell&quot;</span><span class="p">:</span><span class="n">cell</span><span class="p">}</span>
            <span class="n">sub_dict_2</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;unRow&quot;</span><span class="p">:</span><span class="n">idx</span><span class="p">}</span>
            <span class="n">main_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_barcode&quot;</span><span class="p">:</span><span class="n">sub_dict_1</span><span class="p">,</span>
                         <span class="s2">&quot;_cellRow&quot;</span><span class="p">:</span><span class="n">sub_dict_2</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;unCluster&quot;</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="p">)}</span>
                <span class="n">list_of_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

            <span class="n">master_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">main_dict</span><span class="p">,</span> <span class="n">list_of_nodes</span><span class="p">])</span>

        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">master_list</span><span class="p">)</span>
        <span class="n">replace_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39; &#39;</span><span class="p">:</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">:</span><span class="s1">&#39;&quot;&#39;</span><span class="p">}</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">replace_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">regexp</span>  <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">replace_dict</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> 
        <span class="n">obj</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
            <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">convert_graph_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The graph structure stored in the attribute\</span>
<span class="sd">            self.J has to be formatted into a \</span>
<span class="sd">            JSON file. This function takes care\</span>
<span class="sd">            of that task. The output file is \</span>
<span class="sd">            named &#39;cluster_tree.json&#39; and is\</span>
<span class="sd">            equivalent to the &#39;cluster_tree.json&#39;\</span>
<span class="sd">            file produced by too-many-cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;cluster_tree.json&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>
        <span class="n">replace_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39; &#39;</span><span class="p">:</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span><span class="s1">&#39;null&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">:</span><span class="s1">&#39;&quot;&#39;</span><span class="p">}</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">replace_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">regexp</span>  <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">replace_dict</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> 
        <span class="n">obj</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
            <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">generate_cell_annotation_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
            <span class="n">tag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;cell_annotation_labels&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function stores a CSV file with\</span>
<span class="sd">            the labels for each cell.</span>

<span class="sd">        :param column: Name of the\</span>
<span class="sd">            column in the .obs data frame of\</span>
<span class="sd">            the AnnData object that contains\</span>
<span class="sd">            the labels to be used for the tree\</span>
<span class="sd">            visualization. For example, cell \</span>
<span class="sd">            types.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tag</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;.csv&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">tag</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_annotations_path</span> <span class="o">=</span> <span class="n">fname</span>

        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_ann_col</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ca</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;item&#39;</span><span class="p">]</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
        <span class="n">ca</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">create_data_for_tmci</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">tmci_mtx_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;tmci_mtx_data&quot;</span><span class="p">,</span>
            <span class="n">list_of_genes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
            <span class="n">path_to_genes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">create_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce the 10X files for a given set of\</span>
<span class="sd">            genes.  This function produces the\</span>
<span class="sd">            genes x cells matrix market format matrix,\</span>
<span class="sd">            the genes.tsv file and the barcodes.</span>
<span class="sd">        If a path is provided for the genes, then the\</span>
<span class="sd">            first column of the csv file must have the\</span>
<span class="sd">            gene names.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">tmci_mtx_dir</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Genes</span>
        <span class="n">genes_f</span> <span class="o">=</span> <span class="s2">&quot;genes.tsv&quot;</span>
        <span class="n">genes_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">,</span> <span class="n">genes_f</span><span class="p">)</span>

        <span class="n">var_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">col_indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_to_genes</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path_to_genes</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1">#The first column should contain the genes.</span>
            <span class="n">list_of_genes</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_genes</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">list_of_genes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gene</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">var_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>
                <span class="n">col_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>
                <span class="n">col_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_index</span><span class="p">)</span>

            <span class="n">G_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span><span class="n">col_indices</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#If not list is provided, use all the genes.</span>
            <span class="n">var_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var_names</span>
            <span class="n">G_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span>

        <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_names</span><span class="p">,</span><span class="n">var_names</span><span class="p">]</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
            <span class="n">genes_f</span><span class="p">,</span>
            <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Barcodes</span>
        <span class="n">barcodes_f</span> <span class="o">=</span> <span class="s2">&quot;barcodes.tsv&quot;</span>
        <span class="n">barcodes_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">,</span>
                                  <span class="n">barcodes_f</span><span class="p">)</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs_names</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
            <span class="n">barcodes_f</span><span class="p">,</span>
            <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Matrix</span>
        <span class="k">if</span> <span class="n">create_matrix</span><span class="p">:</span>
            <span class="n">matrix_f</span> <span class="o">=</span> <span class="s2">&quot;matrix.mtx&quot;</span>
            <span class="n">matrix_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">,</span>
                                    <span class="n">matrix_f</span><span class="p">)</span>
            <span class="n">mmwrite</span><span class="p">(</span><span class="n">matrix_f</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">G_mtx</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">visualize_with_tmc_interactive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">path_to_tmc_interactive</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">use_column_for_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">port</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9991</span><span class="p">,</span>
            <span class="n">include_matrix_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">tmci_mtx_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function produces a visualization\</span>
<span class="sd">                using too-many-cells-interactive.</span>

<span class="sd">        :param path_to_tmc_interactive: Path to \</span>
<span class="sd">                the too-many-cells-interactive \</span>
<span class="sd">                directory.</span>
<span class="sd">        :param use_column_for_labels: Name of the\</span>
<span class="sd">                column in the .obs data frame of\</span>
<span class="sd">                the AnnData object that contains\</span>
<span class="sd">                the labels to be used in the tree\</span>
<span class="sd">                visualization. For example, cell \</span>
<span class="sd">                types.</span>
<span class="sd">        :param port: Port to be used to open\</span>
<span class="sd">                the app in your browser using\</span>
<span class="sd">                the address localhost:port.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;cluster_tree.json&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">tree_path</span> <span class="o">=</span> <span class="n">fname</span>
        <span class="n">port_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>


        <span class="n">bash_exec</span> <span class="o">=</span> <span class="s2">&quot;./start-and-load.sh&quot;</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">use_column_for_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">label_path_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">label_path</span>     <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generate_cell_annotation_file</span><span class="p">(</span>
                    <span class="n">use_column_for_labels</span><span class="p">)</span>
            <span class="n">label_path_str</span> <span class="o">=</span> <span class="s2">&quot;--label-path&quot;</span>
            <span class="n">label_path</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_annotations_path</span>

        <span class="k">if</span> <span class="n">include_matrix_data</span><span class="p">:</span>
            <span class="n">matrix_path_str</span> <span class="o">=</span> <span class="s2">&quot;--matrix-dir&quot;</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmci_mtx_dir</span><span class="p">):</span>
                <span class="n">matrix_dir</span> <span class="o">=</span> <span class="n">tmci_mtx_dir</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No path for TMCI mtx.&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating TMCI mtx data.&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">create_data_for_tmci</span><span class="p">()</span>

                <span class="n">matrix_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix_path_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">matrix_dir</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">command</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">bash_exec</span><span class="p">,</span>
                <span class="n">matrix_path_str</span><span class="p">,</span>
                <span class="n">matrix_dir</span><span class="p">,</span>
                <span class="s1">&#39;--tree-path&#39;</span><span class="p">,</span>
                <span class="n">tree_path</span><span class="p">,</span>
                <span class="n">label_path_str</span><span class="p">,</span>
                <span class="n">label_path</span><span class="p">,</span>
                <span class="s1">&#39;--port&#39;</span><span class="p">,</span>
                <span class="n">port_str</span>
                <span class="p">]</span>

        <span class="n">command</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">command</span><span class="p">))</span>
        <span class="n">command</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>

        <span class="c1">#Run the command as if we were inside the</span>
        <span class="c1">#too-many-cells-interactive folder.</span>
        <span class="n">final_command</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(cd </span><span class="si">{</span><span class="n">path_to_tmc_interactive</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&amp;&amp; </span><span class="si">{</span><span class="n">command</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="c1">#print(final_command)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;localhost:&#39;</span> <span class="o">+</span> <span class="n">port_str</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Once the app is running, just type in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;your browser </span><span class="se">\n</span><span class="s2">        </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="n">txt</span><span class="o">=</span><span class="s2">&quot;The app will start loading after pressing Enter.&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="n">pause</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Press Enter to continue ...&#39;</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">final_command</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">update_cell_annotations</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a column of cell annotations in the \</span>
<span class="sd">        AnnData.obs data frame. The column in the \</span>
<span class="sd">        data frame should be called &quot;label&quot;. The \</span>
<span class="sd">        name of the column in the AnnData.obs \</span>
<span class="sd">        data frame is provided by the user through \</span>
<span class="sd">        the column argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing label column.&quot;</span><span class="p">)</span>

        <span class="c1">#Reindex the data frame.</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data frame size mismatch.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span>  <span class="n">df</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">generate_matrix_from_signature_file</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">signature_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a matrix from the signature provided \</span>
<span class="sd">            through a file. The entries with a positive</span>
<span class="sd">            weight are assumed to be upregulated and \</span>
<span class="sd">            those with a negative weight are assumed \</span>
<span class="sd">            to be downregulated. The algorithm will \</span>
<span class="sd">            standardize the matrix, i.e., centering \</span>
<span class="sd">            and scaling.</span>

<span class="sd">        If the signature has both positive and \</span>
<span class="sd">            negative weights, two versions will be \</span>
<span class="sd">            created. The unadjusted version simply \</span>
<span class="sd">            computes a weighted average using the \</span>
<span class="sd">            weights provided in the signature file.\</span>
<span class="sd">            In the adjusted version the weights \</span>
<span class="sd">            are adjusted to give equal weight to the \</span>
<span class="sd">            upregulated and downregulated genes.</span>

<span class="sd">        Assumptions</span>

<span class="sd">        We assume that the file has at least two \</span>
<span class="sd">            columns. One should be named &quot;Gene&quot; and \</span>
<span class="sd">            the other &quot;Weight&quot;. \</span>
<span class="sd">            The count matrix has cells for rows and \</span>
<span class="sd">            genes for columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df_signature</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">signature_path</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Z_is_sparse</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>

        <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">up_reg</span> <span class="o">=</span> <span class="n">vec</span> <span class="o">*</span> <span class="mi">0</span>
        <span class="n">down_reg</span> <span class="o">=</span> <span class="n">vec</span> <span class="o">*</span> <span class="mi">0</span>

        <span class="n">up_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">up_weight</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">down_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">down_weight</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">df_signature</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">df_signature</span><span class="p">[</span><span class="s2">&quot;Weight&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">gene</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">gene</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Z</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">col_index</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">Z_is_sparse</span><span class="p">:</span>
                <span class="n">gene_col</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="n">col_index</span><span class="p">)</span>
                <span class="n">gene_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">gene_col</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gene_col</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span><span class="n">col_index</span><span class="p">]</span>

            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">:</span>
                <span class="n">up_reg</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">gene_col</span>
                <span class="n">up_weight</span> <span class="o">+=</span> <span class="n">weight</span>
                <span class="n">up_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">down_reg</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">gene_col</span>
                <span class="n">down_weight</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
                <span class="n">down_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">total_counts</span> <span class="o">=</span> <span class="n">up_count</span> <span class="o">+</span> <span class="n">down_count</span>
        <span class="n">total_weight</span> <span class="o">=</span> <span class="n">up_weight</span> <span class="o">+</span> <span class="n">down_weight</span>

        <span class="n">list_of_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_of_gvecs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">UnAdjSign</span> <span class="o">=</span> <span class="n">up_reg</span> <span class="o">+</span> <span class="n">down_reg</span>
        <span class="n">UnAdjSign</span> <span class="o">/=</span> <span class="n">total_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;UnAdjSign&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">UnAdjSign</span>
        <span class="n">list_of_gvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">UnAdjSign</span><span class="p">)</span>
        <span class="n">list_of_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;UnAdjSign&quot;</span><span class="p">)</span>

        <span class="n">up_factor</span> <span class="o">=</span> <span class="n">down_count</span> <span class="o">/</span> <span class="n">total_counts</span>
        <span class="n">down_factor</span> <span class="o">=</span> <span class="n">up_count</span> <span class="o">/</span> <span class="n">total_counts</span>

        <span class="n">modified_total_counts</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">up_count</span> <span class="o">*</span> <span class="n">down_count</span>
        <span class="n">modified_total_counts</span> <span class="o">/=</span> <span class="n">total_counts</span>

        <span class="n">check</span> <span class="o">=</span> <span class="n">up_factor</span><span class="o">*</span><span class="n">up_count</span> <span class="o">+</span> <span class="n">down_factor</span><span class="o">*</span><span class="n">down_count</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">up_count</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">down_count</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">total_counts</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">modified_total_counts</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">check</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">up_factor</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">down_factor</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="n">mixed_signs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">up_count</span><span class="p">:</span>
            <span class="n">UpReg</span>   <span class="o">=</span> <span class="n">up_reg</span> <span class="o">/</span> <span class="n">up_count</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;UpReg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">UpReg</span>
            <span class="n">list_of_gvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">UpReg</span><span class="p">)</span>
            <span class="n">list_of_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;UpReg&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UpRegulated genes: stats&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;UpReg&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">mixed_signs</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">down_count</span><span class="p">:</span>
            <span class="n">DownReg</span>   <span class="o">=</span> <span class="n">down_reg</span> <span class="o">/</span> <span class="n">down_count</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;DownReg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DownReg</span>
            <span class="n">list_of_gvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DownReg</span><span class="p">)</span>
            <span class="n">list_of_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DownReg&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DownRegulated genes: stats&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;DownReg&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Note: In our representation, &quot;</span> 
                   <span class="s2">&quot;the higher the value of a downregulated &quot;</span>
                   <span class="s2">&quot;gene, the more downregulated it is.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mixed_signs</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">mixed_signs</span><span class="p">:</span>
            <span class="n">AdjSign</span>  <span class="o">=</span> <span class="n">up_factor</span> <span class="o">*</span> <span class="n">up_reg</span>
            <span class="n">AdjSign</span> <span class="o">+=</span> <span class="n">down_factor</span> <span class="o">*</span> <span class="n">down_reg</span>
            <span class="n">AdjSign</span> <span class="o">/=</span> <span class="n">modified_total_counts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;AdjSign&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">AdjSign</span>
            <span class="n">list_of_gvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AdjSign</span><span class="p">)</span>
            <span class="n">list_of_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;AdjSign&quot;</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">list_of_gvecs</span><span class="p">)</span>

        <span class="c1">#This function will produce the </span>
        <span class="c1">#barcodes.tsv and the genes.tsv file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_data_for_tmci</span><span class="p">(</span>
            <span class="n">list_of_genes</span> <span class="o">=</span> <span class="n">list_of_names</span><span class="p">,</span>
            <span class="n">create_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">mtx_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">,</span> <span class="s2">&quot;matrix.mtx&quot;</span><span class="p">)</span>

        <span class="n">mmwrite</span><span class="p">(</span><span class="n">mtx_path</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">load_graph</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dot_fname</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the dot file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dot_fname</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;graph.dot&#39;</span>
            <span class="n">dot_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dot_fname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;File does not exists.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">nx_agraph</span><span class="o">.</span><span class="n">read_dot</span><span class="p">(</span><span class="n">dot_fname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>
        <span class="n">n_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>

        <span class="c1"># Change string labels to integers.</span>
        <span class="n">D</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">):</span>
            <span class="n">D</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">k</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># self.G = nx.convert_node_labels_to_integers(self.G)</span>
        <span class="c1"># Changing the labels to integers using the above </span>
        <span class="c1"># function follows a different numbering scheme to </span>
        <span class="c1"># that given by the labels of the node.</span>

        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">get_path_from_root_to_node</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a given node, we find the path from the root </span>
<span class="sd">        to that node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">node</span> <span class="o">=</span> <span class="n">target</span>
        <span class="n">path_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="n">modularity_vec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">node</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Get an iterator for the predecessors.</span>
            <span class="c1"># There should only be one predecessor.</span>
            <span class="n">predecessors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">predecessors</span><span class="p">)</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">_node</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;Q&quot;</span><span class="p">]</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
            <span class="n">path_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">modularity_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

        <span class="c1"># We assume that the distance between two children</span>
        <span class="c1"># nodes is equal to the modularity of the parent node.</span>
        <span class="c1"># Hence, the distance from a child to a parent is </span>
        <span class="c1"># half the modularity.</span>
        <span class="n">modularity_vec</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">modularity_vec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">path_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path_vec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">path_vec</span><span class="p">,</span> <span class="n">modularity_vec</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">get_path_from_node_x_to_node_y</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a given pair of nodes x and y, we find the</span>
<span class="sd">        path between those nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_path</span><span class="p">,</span> <span class="n">x_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_from_root_to_node</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_path</span><span class="p">,</span> <span class="n">y_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_from_root_to_node</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">x_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x_path</span><span class="p">)</span>
        <span class="n">y_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">y_path</span><span class="p">)</span>

        <span class="c1"># print(x_dist)</span>
        <span class="c1"># print(y_dist)</span>

        <span class="c1"># print(&quot;===========&quot;)</span>

        <span class="c1"># print(x_path)</span>
        <span class="c1"># print(y_path)</span>

        <span class="c1"># print(&quot;===========&quot;)</span>

        <span class="n">intersection</span> <span class="o">=</span> <span class="n">x_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">y_set</span><span class="p">)</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>
        <span class="n">n_intersection</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>

        <span class="n">pivot_node</span> <span class="o">=</span> <span class="n">x_path</span><span class="p">[</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>
        <span class="n">pivot_dist</span> <span class="o">=</span> <span class="n">x_dist</span><span class="p">[</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>

        <span class="n">x_path</span> <span class="o">=</span> <span class="n">x_path</span><span class="p">[:</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>
        <span class="n">y_path</span> <span class="o">=</span> <span class="n">y_path</span><span class="p">[:</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>
        <span class="n">y_path</span> <span class="o">=</span> <span class="n">y_path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">x_dist</span> <span class="o">=</span> <span class="n">x_dist</span><span class="p">[:</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>
        <span class="n">y_dist</span> <span class="o">=</span> <span class="n">y_dist</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>
        <span class="n">y_dist</span> <span class="o">=</span> <span class="n">y_dist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">full_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x_path</span><span class="p">,</span><span class="n">pivot_node</span><span class="p">,</span><span class="n">y_path</span><span class="p">))</span>
        <span class="n">full_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x_dist</span><span class="p">,</span> <span class="n">pivot_dist</span><span class="p">,</span> <span class="n">pivot_dist</span><span class="p">,</span> <span class="n">y_dist</span><span class="p">))</span>
        <span class="n">full_dist</span> <span class="o">=</span> <span class="n">full_dist</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

        <span class="c1"># print(full_path) </span>
        <span class="c1"># print(full_dist)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="n">full_dist</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">compute_cluster_mean_expression</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> 
            <span class="n">node</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
            <span class="n">genes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
            <span class="n">output_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>

        <span class="c1">#Get all the descendants for a given node.</span>
        <span class="c1">#This is a set.</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#This is a leaf node.</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Make sure these are leaf nodes.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="n">is_string</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">genes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">is_string</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">list_of_genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">genes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">list_of_genes</span> <span class="o">=</span> <span class="n">genes</span>

        <span class="n">exp_vec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mean_exp</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">list_of_genes</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">gene</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gene</span><span class="si">=}</span><span class="s2"> was not found.&quot;</span><span class="p">)</span>

            <span class="n">col_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">mean_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">col_index</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">exp_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_exp</span><span class="p">)</span>

        <span class="c1"># print(f&quot;{total_exp=}&quot;)</span>
        <span class="c1"># print(f&quot;{n_cells=}&quot;)</span>
        <span class="c1"># print(f&quot;{mean_exp=}&quot;)</span>

        <span class="k">if</span> <span class="n">is_string</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">output_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mean_exp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exp_vec</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">load_cluster_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cluster_file_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the cluster file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_file_path</span><span class="p">):</span>
            <span class="n">cluster_fname</span> <span class="o">=</span> <span class="n">cluster_file_path</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;clusters.csv&#39;</span>
            <span class="n">cluster_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cluster_fname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;File does not exists.&quot;</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">cluster_fname</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">])</span>


    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">plot_expression_from_node_x_to_node_y</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">genes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a given pair of nodes x and y, we compute the \</span>
<span class="sd">            gene expression path along the path connecting\</span>
<span class="sd">            those nodes.</span>
<span class="sd">        Make sure that property set_of_leaf_nodes is\</span>
<span class="sd">            populated with the correct information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">genes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">list_of_genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">genes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">list_of_genes</span> <span class="o">=</span> <span class="n">genes</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_from_node_x_to_node_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">path_vec</span><span class="p">,</span> <span class="n">dist_vec</span> <span class="o">=</span> <span class="n">T</span>
        <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_vec</span><span class="p">)</span>
        <span class="n">n_genes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_genes</span><span class="p">)</span>
        <span class="n">exp_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_genes</span><span class="p">,</span><span class="n">n_nodes</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">col</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path_vec</span><span class="p">):</span>
            <span class="n">g_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_cluster_mean_expression</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">list_of_genes</span><span class="p">)</span>
            <span class="n">exp_mat</span><span class="p">[:,</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_exp</span>

        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="c1"># bogus_names = [&quot;Gene A&quot;, &quot;Gene B&quot;]</span>
        <span class="c1"># colors = [&quot;blue&quot;, &quot;red&quot;]</span>

        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">gene</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_genes</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">,</span>
                    <span class="n">exp_mat</span><span class="p">[</span><span class="n">row</span><span class="p">,:],</span>
                    <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="n">gene</span><span class="p">,</span>
                    <span class="c1"># label=bogus_names[row],</span>
                    <span class="c1"># color = colors[row]</span>
                    <span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;From node </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> to node </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># txt = f&quot;From node X to node Y&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Gene expression&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Distance (modularity units)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;sci&#39;</span><span class="p">,</span>
                             <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
                             <span class="n">scilimits</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;expression_path.pdf&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Plot has been generated.&quot;</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">plot_radial_tree_from_dot_file</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dot_fname</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dot_fname</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;graph.dot&#39;</span>
            <span class="n">dot_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dot_fname</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DOT file not found.&quot;</span><span class="p">)</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;output_graph.svg&#39;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

        <span class="n">command</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;twopi&#39;</span><span class="p">,</span>
                <span class="s1">&#39;-Groot=0&#39;</span><span class="p">,</span>
                <span class="s1">&#39;-Goverlap=true&#39;</span><span class="p">,</span>
                <span class="s1">&#39;-Granksep=2&#39;</span><span class="p">,</span>
                <span class="s1">&#39;-Tsvg&#39;</span><span class="p">,</span>
                <span class="n">dot_fname</span><span class="p">,</span>
                <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span>
                <span class="n">fname</span><span class="p">,</span>
                <span class="p">]</span>
        <span class="n">command</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">compute_marker_mean_value_for_cell</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">marker</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">cell</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">CA</span> <span class="o">=</span> <span class="n">cell_ann_col</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">col_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell</span>
        <span class="n">mean_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">col_index</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">mean_exp</span>
    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">compute_marker_median_value_for_cell</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">marker</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">cell</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">CA</span> <span class="o">=</span> <span class="n">cell_ann_col</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">col_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">col_index</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">compute_mean_expression_from_indices</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">marker</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">marker</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">col_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">mean_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">col_index</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">mean_exp</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">compute_median_expression_from_indices</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">marker</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">marker</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">col_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">col_index</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">find_stable_tree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cell_group_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">cell_marker_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
            <span class="n">clean_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
            <span class="n">favor_minorities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">conversion_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
            <span class="n">confirmation_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
            <span class="n">elimination_ratio</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>
            <span class="n">homogeneous_leafs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">follow_parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">follow_majority</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">no_mixtures</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">storage_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;stable_tree&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">CA</span> <span class="o">=</span> <span class="n">cell_ann_col</span>
        <span class="n">tmc_obj</span> <span class="o">=</span> <span class="n">TooManyCells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage_path</span><span class="p">)</span>

        <span class="n">something_has_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

            <span class="n">tmc_obj</span><span class="o">.</span><span class="n">annotate_using_tree</span><span class="p">(</span>
            <span class="n">cell_group_path</span><span class="p">,</span>
            <span class="n">cell_marker_path</span><span class="p">,</span>
            <span class="n">cell_ann_col</span><span class="p">,</span>
            <span class="n">clean_threshold</span><span class="p">,</span>
            <span class="n">favor_minorities</span><span class="p">,</span>
            <span class="n">conversion_threshold</span><span class="p">,</span>
            <span class="n">confirmation_threshold</span><span class="p">,</span>
            <span class="n">elimination_ratio</span><span class="p">,</span>
            <span class="n">homogeneous_leafs</span><span class="p">,</span>
            <span class="n">follow_parent</span><span class="p">,</span>
            <span class="n">follow_majority</span><span class="p">,</span>
            <span class="n">no_mixtures</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">tmc_obj</span><span class="o">.</span><span class="n">labels_have_changed</span><span class="p">:</span>
                <span class="c1">#No cells have changed their label</span>
                <span class="c1">#and no cell has been tagged for </span>
                <span class="c1">#elimination.</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nothing has changed.&quot;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="n">something_has_changed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1">#We know the labels have changed.</span>
            <span class="c1">#We will only recompute the tree if </span>
            <span class="c1">#cells have been eliminated.</span>

            <span class="n">S</span> <span class="o">=</span> <span class="n">tmc_obj</span><span class="o">.</span><span class="n">cells_to_be_eliminated</span>

            <span class="k">if</span> <span class="mi">0</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No cells have been eliminated.&quot;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="c1">#Cells have been eliminated.</span>
            <span class="c1">#A new tree will be generated.</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">tmc_obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">tmc_obj</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tmc_obj</span> <span class="o">=</span> <span class="n">TooManyCells</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">storage_path</span><span class="p">)</span>
            <span class="n">tmc_obj</span><span class="o">.</span><span class="n">run_spectral_clustering</span><span class="p">()</span>
            <span class="n">tmc_obj</span><span class="o">.</span><span class="n">store_outputs</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">something_has_changed</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">iterations</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">check_leaf_homogeneity</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">CA</span> <span class="o">=</span> <span class="n">cell_ann_col</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1">#Child</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#The node is already homogeneous</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#We found one leaf node that is not</span>
                <span class="c1">#homogeneous.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes_are_homogeneous</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes_are_homogeneous</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">homogenize_leaf_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
            <span class="n">follow_parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">follow_majority</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">follow_parent</span> <span class="o">==</span> <span class="n">follow_majority</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Homogeneous leafs strategy:&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strategy has to be unique.&quot;</span><span class="p">)</span>

        <span class="n">CA</span> <span class="o">=</span> <span class="n">cell_ann_col</span>
        <span class="n">elim_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="c1">#print(f&quot;{parent}--&gt;{node}&quot;)</span>

            <span class="c1">#Child</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">vc</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">child_majority</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">child_ratio</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">child_ratio</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#The node is already homogeneous</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">follow_parent</span><span class="p">:</span>
                <span class="c1">#Parent</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">parent</span><span class="p">])</span>
                <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">vc</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">parent_majority</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1">#Who is different from the parent?</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">S</span> <span class="o">!=</span> <span class="n">parent_majority</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">elim_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">follow_majority</span><span class="p">:</span>
                <span class="c1">#Who is different from the child&#39;s majority?</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">S</span> <span class="o">!=</span> <span class="n">child_majority</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">elim_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="k">continue</span>

        <span class="k">return</span> <span class="n">elim_set</span>


    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">erase_cells_from_json_file</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">json_file_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">target_json_file_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="c1">#{&#39;_barcode&#39;:</span>
        <span class="c1">#{&#39;unCell&#39;: &#39;CAGCTGGCACGGTAGA-176476-OM&#39;},</span>
        <span class="c1">#&#39;_cellRow&#39;: {&#39;unRow&#39;: 29978}}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">json_file_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">folder</span> <span class="o">=</span> <span class="s2">&quot;tmc_outputs&quot;</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;cluster_tree.json&quot;</span>
            <span class="n">source_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;pruned_cluster_tree.json&quot;</span>
            <span class="n">target_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">source_fname</span> <span class="o">=</span> <span class="n">json_file_path</span>
            <span class="n">target_fname</span> <span class="o">=</span> <span class="n">target_json_file_path</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">source_fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

        <span class="n">list_of_regexp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">replace_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">barcode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cells_to_be_eliminated</span><span class="p">):</span>

            <span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;[{][^{]+[{][a-zA-Z&quot;:]+[ ]?[&quot;]&#39;</span>
            <span class="c1"># txt += &quot;(?P&lt;barcode&gt;&quot;</span>
            <span class="n">txt</span> <span class="o">+=</span> <span class="n">barcode</span>
            <span class="c1"># txt += &quot;)&quot;</span>
            <span class="n">txt</span> <span class="o">+=</span> <span class="s1">&#39;[&quot;][}][^}]+[}]</span><span class="si">{2}</span><span class="s1">[,]?&#39;</span>
            <span class="n">list_of_regexp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="n">replace_dict</span><span class="p">[</span><span class="n">barcode</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">list_of_regexp</span><span class="p">)</span>
        <span class="n">regexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">target_fname</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
            <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


    <span class="c1">#=================================================</span>
    <span class="k">def</span> <span class="nf">check_if_cells_belong_to_group</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cells</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
            <span class="n">group</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">conversion_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
            <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The cells parameter is a series that contains</span>
<span class="sd">        the cells types as values and the indices </span>
<span class="sd">        correspond to the barcodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#This is the question we are trying to</span>
        <span class="c1">#answer.</span>
        <span class="n">belongs_to_group</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">CA</span> <span class="o">=</span> <span class="n">cell_ann_col</span>

        <span class="c1">#What cells types belong to </span>
        <span class="c1">#the given group?</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_to_cell_types</span><span class="p">[</span><span class="n">group</span><span class="p">]</span>
        <span class="n">cell_types_in_group</span> <span class="o">=</span> <span class="n">x</span>

        <span class="c1">#Now we are going to iterate over the</span>
        <span class="c1">#cells that belong to the majority</span>
        <span class="c1">#group. We do this to determine if </span>
        <span class="c1">#the non-majority cells could qualify</span>
        <span class="c1">#as a member of the majority group by</span>
        <span class="c1">#using a marker for cells of the </span>
        <span class="c1">#majority group.</span>
        <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">cell_types_in_group</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">belongs_to_group</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Are they </span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">?&quot;</span><span class="p">)</span>
            <span class="n">markers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_type_to_markers</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">marker</span> <span class="ow">in</span> <span class="n">markers</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_to_median_value</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span>
                <span class="n">marker_value</span> <span class="o">=</span> <span class="n">x</span>
                <span class="k">if</span> <span class="n">marker_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1">#Nothing to be done.</span>
                    <span class="k">continue</span>

                <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_median_expression_from_indices</span><span class="p">(</span>
                    <span class="n">marker</span><span class="p">,</span> <span class="n">cells</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="n">expression_value</span> <span class="o">=</span> <span class="n">x</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">marker_value</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="c1">#Let X be the mean/median expression </span>
                <span class="c1">#value of that marker for the</span>
                <span class="c1">#given minority.</span>
                <span class="c1">#Let Y be the mean/median expression</span>
                <span class="c1">#value of that same marker for</span>
                <span class="c1">#the cells in the sample that </span>
                <span class="c1">#are known to express that</span>
                <span class="c1">#marker. If X is above Y </span>
                <span class="c1">#multiplied by the conversion</span>
                <span class="c1">#threshold, then we add that</span>
                <span class="c1">#minority to the majority,</span>
                <span class="k">if</span> <span class="n">marker_value</span> <span class="o">*</span> <span class="n">conversion_threshold</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">belongs_to_group</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span><span class="s2">&quot;To convert.&quot;</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">belongs_to_group</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cells</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&gt;&gt;&gt;Cells do not belong to </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>




    <span class="c1">#=====================================</span>
    <span class="k">def</span> <span class="nf">annotate_using_tree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cell_group_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">cell_marker_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
            <span class="n">clean_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
            <span class="n">favor_minorities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">conversion_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
            <span class="n">confirmation_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
            <span class="n">elimination_ratio</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>
            <span class="n">homogeneous_leafs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">follow_parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">follow_majority</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">no_mixtures</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cell_group_path</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">cell_group_path</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;File does not exists.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cell_marker_path</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">cell_marker_path</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;File does not exists.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">homogeneous_leafs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">follow_majority</span> <span class="o">==</span> <span class="n">follow_parent</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Homogeneous leafs strategy:&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strategy is not unique.&quot;</span><span class="p">)</span>

        <span class="n">df_cg</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">cell_group_path</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cell to Group file&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df_cg</span><span class="p">)</span>
        <span class="n">CA</span> <span class="o">=</span> <span class="n">cell_ann_col</span>

        <span class="n">df_cm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">cell_marker_path</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cell to Marker file&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df_cm</span><span class="p">)</span>

        <span class="n">cell_to_group</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cell_types_to_erase</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_to_cell_types</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells_to_be_eliminated</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#Create the cell to group dictionary and</span>
        <span class="c1">#the group to cell dictionary</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_cg</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;Cell&quot;</span><span class="p">]</span>
            <span class="n">group</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;Group&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">cell</span>
            <span class="k">elif</span> <span class="n">group</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
                <span class="n">cell_types_to_erase</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">cell_to_group</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">group_to_cell_types</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>


        <span class="c1">#Create the cell to markers dictionary and</span>
        <span class="c1">#marker to value dictionary.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_type_to_markers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">marker_to_mean_value</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">marker_to_median_value</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_cm</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>

            <span class="n">cell</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;Cell&quot;</span><span class="p">]</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;Marker&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_type_to_markers</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">cell</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_to_group</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">marker</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">marker_to_mean_value</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_marker_median_value_for_cell</span><span class="p">(</span>
                    <span class="n">marker</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">marker_to_median_value</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

        <span class="c1">#Eliminate cells that belong to the erase category.</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_types_to_erase</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">cell_types_to_erase</span><span class="p">)</span>
            <span class="n">n_cells</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">vc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
            <span class="c1">#Take the complement of the cells we </span>
            <span class="c1">#want to erase.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_cells</span><span class="si">}</span><span class="s2"> cells have been deleted.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">vc</span><span class="p">)</span>

        <span class="c1">#Create a series where the original cell </span>
        <span class="c1">#annotations have been mapped to their </span>
        <span class="c1">#corresponding group.</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cell</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">cell_to_group</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="n">group</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">S</span> <span class="o">==</span> <span class="n">cell</span>
            <span class="n">S</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">)</span>
        <span class="n">OCA</span> <span class="o">=</span> <span class="s2">&quot;original_cell_annotations&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">OCA</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span>
        <span class="n">vc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Relabeled cell counts&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">vc</span><span class="p">)</span>

        <span class="n">node</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">parent_majority</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">parent_ratio</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># We use a deque to do a breadth-first traversal.</span>
        <span class="n">DQ</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent_majority</span><span class="p">,</span> <span class="n">parent_ratio</span><span class="p">)</span>
        <span class="n">DQ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

        <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Elimination container</span>
        <span class="n">elim_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labels_have_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">while</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">DQ</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">DQ</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">parent_majority</span><span class="p">,</span> <span class="n">parent_ratio</span> <span class="o">=</span> <span class="n">T</span>
            <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="n">is_leaf_node</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">is_leaf_node</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                    <span class="n">nodes</span><span class="p">)</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">node_size</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working with </span><span class="si">{</span><span class="n">node</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Size of </span><span class="si">{</span><span class="n">node</span><span class="si">=}</span><span class="s2">: </span><span class="si">{</span><span class="n">node_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">vc</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">vc</span><span class="p">)</span>

            <span class="n">majority_group</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">majority_ratio</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">majority_ratio</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#The cluster is homogeneous.</span>
                <span class="c1">#Nothing to do here.</span>
                <span class="k">continue</span>


            <span class="k">if</span> <span class="n">majority_ratio</span> <span class="o">&lt;</span> <span class="n">clean_threshold</span><span class="p">:</span>
                <span class="c1">#We are below clean_threshold, so we add </span>
                <span class="c1">#these nodes to the deque for </span>
                <span class="c1">#further processing.</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding node </span><span class="si">{</span><span class="n">child</span><span class="si">}</span><span class="s2"> to DQ.&quot;</span><span class="p">)</span>
                    <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span><span class="p">,</span>
                         <span class="n">majority_group</span><span class="p">,</span>
                         <span class="n">majority_ratio</span><span class="p">)</span>
                    <span class="n">DQ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#We are above the cleaning threshold. </span>
                <span class="c1">#Hence, we can star cleaning this node.</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cleaning </span><span class="si">{</span><span class="n">node</span><span class="si">=}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">majority_group</span><span class="si">=}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">majority_ratio</span><span class="si">=}</span><span class="s2">.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">no_mixtures</span><span class="p">:</span>
                    <span class="c1">#We do not allow minorities.</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">S</span> <span class="o">!=</span> <span class="n">majority_group</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                    <span class="n">elim_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1">#We are going to iterate over all the </span>
                <span class="c1">#groups below the majority group.</span>
                <span class="c1">#We call these the minority_groups.</span>

                <span class="c1">#We have two options. Start checking if</span>
                <span class="c1">#the minority actually belongs to the </span>
                <span class="c1">#majority or first check if the minority</span>
                <span class="c1">#is indeed a true minority.</span>
                <span class="k">for</span> <span class="n">minority_group</span><span class="p">,</span> <span class="n">mr</span> <span class="ow">in</span> <span class="n">vc</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                    <span class="n">minority_ratio</span> <span class="o">=</span> <span class="n">mr</span>

                    <span class="c1">#These are the cells that belong to one</span>
                    <span class="c1">#of the minorities. We label them as</span>
                    <span class="c1">#Q because their current status </span>
                    <span class="c1">#is under question.</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">S</span> <span class="o">==</span> <span class="n">minority_group</span>
                    <span class="n">minority_size</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">minority_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1">#Nothing to be done with this and </span>
                        <span class="c1">#subsequent minorities because the</span>
                        <span class="c1">#cell ratios are sorted in </span>
                        <span class="c1">#decreasing order. If one is zero,</span>
                        <span class="c1">#the rest are zero too.</span>
                        <span class="k">break</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">minority_ratio</span> <span class="o">&lt;</span> <span class="n">elimination_ratio</span><span class="p">:</span>
                        <span class="c1">#If the ratio is below the </span>
                        <span class="c1">#given threshold, then we </span>
                        <span class="c1">#remove these cells.</span>
                        <span class="n">elim_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="c1">#Check membership</span>
                    <span class="k">if</span> <span class="n">favor_minorities</span><span class="p">:</span>
                        <span class="c1">#We first check if the minority is</span>
                        <span class="c1">#indeed a true minority.</span>
                        <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">check_if_cells_belong_to_group</span><span class="p">(</span>
                            <span class="n">Q</span><span class="p">,</span> 
                            <span class="n">minority_group</span><span class="p">,</span> 
                            <span class="n">conversion_threshold</span><span class="p">,</span>
                            <span class="n">cell_ann_col</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">belongs_to_minority</span> <span class="o">=</span> <span class="n">x</span>
                        <span class="k">if</span> <span class="n">belongs_to_minority</span><span class="p">:</span>
                            <span class="c1">#Move to the next minority.</span>
                            <span class="k">continue</span>
                        <span class="c1">#Otherwise, check if belongs to </span>
                        <span class="c1">#the majority group.</span>
                        <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">check_if_cells_belong_to_group</span><span class="p">(</span>
                            <span class="n">Q</span><span class="p">,</span> 
                            <span class="n">majority_group</span><span class="p">,</span> 
                            <span class="n">conversion_threshold</span><span class="p">,</span>
                            <span class="n">cell_ann_col</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">identity_was_determined</span> <span class="o">=</span> <span class="n">x</span>
                        <span class="n">belongs_to_majority</span> <span class="o">=</span> <span class="n">x</span>

                        <span class="k">if</span> <span class="n">belongs_to_majority</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">labels_have_changed</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#We first check if the minority is</span>
                        <span class="c1">#actually part of the majority.</span>
                        <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">check_if_cells_belong_to_group</span><span class="p">(</span>
                            <span class="n">Q</span><span class="p">,</span> 
                            <span class="n">majority_group</span><span class="p">,</span> 
                            <span class="n">conversion_threshold</span><span class="p">,</span>
                            <span class="n">cell_ann_col</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">belongs_to_majority</span> <span class="o">=</span> <span class="n">x</span>
                        <span class="k">if</span> <span class="n">belongs_to_majority</span><span class="p">:</span>
                            <span class="c1">#Move to the next minority.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">labels_have_changed</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">continue</span>
                        <span class="c1">#Otherwise, check if belongs to </span>
                        <span class="c1">#the minority group.</span>
                        <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">check_if_cells_belong_to_group</span><span class="p">(</span>
                            <span class="n">Q</span><span class="p">,</span> 
                            <span class="n">minority_group</span><span class="p">,</span> 
                            <span class="n">conversion_threshold</span><span class="p">,</span>
                            <span class="n">cell_ann_col</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">identity_was_determined</span> <span class="o">=</span> <span class="n">x</span>

                    <span class="k">if</span> <span class="n">identity_was_determined</span><span class="p">:</span>
                        <span class="c1">#Nothing to be done.</span>
                        <span class="c1">#Move to the next minority.</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#Cells could not be classified</span>
                        <span class="c1">#and therefore will be eliminated.</span>
                        <span class="n">elim_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>


            <span class="k">if</span> <span class="n">iteration</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c1">#break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>


        <span class="c1">#Elimination phase 1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Elimination set size before homogenization:&quot;</span><span class="p">,</span>
              <span class="nb">len</span><span class="p">(</span><span class="n">elim_set</span><span class="p">))</span>

        <span class="c1">#Homogenization</span>
        <span class="k">if</span> <span class="n">homogeneous_leafs</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">follow_parent</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using parent node majority.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">follow_majority</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using leaf node majority.&quot;</span><span class="p">)</span>

            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">homogenize_leaf_nodes</span><span class="p">(</span>
                <span class="n">CA</span><span class="p">,</span>
                <span class="n">follow_parent</span><span class="p">,</span>
                <span class="n">follow_majority</span><span class="p">)</span>

            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cells lost through homogenization:&quot;</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
                <span class="n">elim_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">elim_set</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total cells lost:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">elim_set</span><span class="p">))</span>
            <span class="n">remaining_cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">remaining_cells</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elim_set</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Remaining cells:&quot;</span><span class="p">,</span> <span class="n">remaining_cells</span><span class="p">)</span>

            <span class="c1">#Create a new category.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">add_categories</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="c1">#Label the cells to be eliminated with &quot;X&quot;.</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">elim_set</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">labels_have_changed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_have_changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generate_cell_annotation_file</span><span class="p">(</span>
                <span class="n">cell_ann_col</span><span class="o">=</span><span class="n">CA</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="s2">&quot;updated_cell_labels&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nothing has changed.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells_to_be_eliminated</span> <span class="o">=</span> <span class="n">elim_set</span>


    <span class="c1">#====END=OF=CLASS=====================</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">input_is_matrix_market</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_full_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#toomanycells.toomanycells.TooManyCells.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>The constructor takes the following inputs.</p>
<p>:param input: Path to input directory or                 AnnData object.
:param output: Path to output directory.
:param input_is_matrix_market: If true,                 the directory should contain a                 .mtx file, a barcodes.tsv file                 and a genes.tsv file.</p>
<p>:return: a TooManyCells object.
:rtype: :obj:<code>TooManyCells</code></p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="nb">input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">AnnData</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">input_is_matrix_market</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_full_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The constructor takes the following inputs.</span>

<span class="sd">    :param input: Path to input directory or \</span>
<span class="sd">            AnnData object.</span>
<span class="sd">    :param output: Path to output directory.</span>
<span class="sd">    :param input_is_matrix_market: If true, \</span>
<span class="sd">            the directory should contain a \</span>
<span class="sd">            .mtx file, a barcodes.tsv file \</span>
<span class="sd">            and a genes.tsv file.</span>

<span class="sd">    :return: a TooManyCells object.</span>
<span class="sd">    :rtype: :obj:`TooManyCells`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#We use a directed graph to enforce the parent</span>
    <span class="c1">#to child relation.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">TooManyCells</span><span class="p">):</span>

        <span class="c1">#Clone the given TooManyCells object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">S</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span> <span class="o">=</span> <span class="n">S</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.h5ad&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Elapsed time for loading: &#39;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">input_is_matrix_market</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">convert_mm_from_source_to_anndata</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.h5ad&#39;</span><span class="p">):</span>
                        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
                        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Elapsed time for &#39;</span> <span class="o">+</span>
                               <span class="s1">&#39;loading: &#39;</span> <span class="o">+</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
                        <span class="k">break</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">AnnData</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="nb">input</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unexpected input type.&#39;</span><span class="p">)</span>

    <span class="c1">#If no output directory is provided,</span>
    <span class="c1">#we use the current working directory.</span>
    <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s2">&quot;tmc_outputs&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Outputs will be saved in: </span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

    <span class="c1">#This column of the obs data frame indicates</span>
    <span class="c1">#the correspondence between a cell and the </span>
    <span class="c1">#leaf node of the spectral clustering tree.</span>
    <span class="n">sp_cluster</span> <span class="o">=</span> <span class="s2">&quot;sp_cluster&quot;</span>
    <span class="n">sp_path</span> <span class="o">=</span> <span class="s2">&quot;sp_path&quot;</span>
    <span class="k">if</span> <span class="n">sp_cluster</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">sp_cluster</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">sp_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">sp_path</span><span class="p">]</span>    <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">sp_cluster</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_index</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">sp_path</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">path_column_index</span> <span class="o">=</span> <span class="n">t</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">delta_clustering</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">final_n_iter</span>     <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#Create a copy to avoid direct modifications</span>
    <span class="c1">#of the original count matrix X.</span>
    <span class="c1">#Note that we are making sure that the </span>
    <span class="c1">#sparse matrix has the CSR format. This</span>
    <span class="c1">#is relevant when we normalize.</span>
    <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">):</span>
        <span class="c1">#Compute the density of the matrix</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">nnz</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1">#If more than 50% of the matrix is occupied,</span>
        <span class="c1">#we generate a dense version of the matrix.</span>
        <span class="n">sparse_threshold</span> <span class="o">=</span> <span class="mf">0.50</span>
        <span class="k">if</span> <span class="n">use_full_matrix</span> <span class="ow">or</span> <span class="n">sparse_threshold</span> <span class="o">&lt;</span> <span class="n">rho</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Using a dense representation&quot;</span> 
                   <span class="s2">&quot; of the count matrix.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Values will be converted to&quot;</span> 
                   <span class="s2">&quot; float32.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1">#Make sure we use a CSR format.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                                   <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                                   <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#The matrix is dense.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The matrix is dense.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Values will be converted to&quot;</span> 
               <span class="s2">&quot; float32.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_genes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too few observations (cells).&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>

    <span class="c1">#Location of the matrix data for TMCI</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">spectral_clustering_has_been_called</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">cells_to_be_eliminated</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;/home/javier/Documents/repos/too-many-cells-interactive&quot;</span>

    <span class="c1"># We use a deque to offer the possibility of breadth-</span>
    <span class="c1"># versus depth-first. Our current implementation</span>
    <span class="c1"># uses depth-first to be consistent with the </span>
    <span class="c1"># numbering scheme of TooManyCellsInteractive.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">DQ</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>


    <span class="c1">#Map a node to the path in the</span>
    <span class="c1">#binary tree that connects the</span>
    <span class="c1">#root node to the given node.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_to_path</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1">#Map a node to a list of indices</span>
    <span class="c1">#that provide access to the JSON</span>
    <span class="c1">#structure.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_to_j_index</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1">#the JSON structure representation</span>
    <span class="c1">#of the tree.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">MultiIndexList</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">node_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#The threshold for modularity to </span>
    <span class="c1">#accept a given partition of a set</span>
    <span class="c1">#of cells.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-9</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">use_twopi_cmd</span>   <span class="o">=</span> <span class="kc">True</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">verbose_mode</span>    <span class="o">=</span> <span class="kc">False</span>
</code></pre></div>
        </details>
    </div>

  </div>






  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.check_if_cells_belong_to_group" class="doc doc-heading">
<code class="highlight language-python"><span class="n">check_if_cells_belong_to_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">conversion_threshold</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">cell_ann_col</span><span class="o">=</span><span class="s1">&#39;cell_annotations&#39;</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.check_if_cells_belong_to_group" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>The cells parameter is a series that contains
the cells types as values and the indices 
correspond to the barcodes.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">check_if_cells_belong_to_group</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cells</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">conversion_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The cells parameter is a series that contains</span>
<span class="sd">    the cells types as values and the indices </span>
<span class="sd">    correspond to the barcodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#This is the question we are trying to</span>
    <span class="c1">#answer.</span>
    <span class="n">belongs_to_group</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">CA</span> <span class="o">=</span> <span class="n">cell_ann_col</span>

    <span class="c1">#What cells types belong to </span>
    <span class="c1">#the given group?</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_to_cell_types</span><span class="p">[</span><span class="n">group</span><span class="p">]</span>
    <span class="n">cell_types_in_group</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1">#Now we are going to iterate over the</span>
    <span class="c1">#cells that belong to the majority</span>
    <span class="c1">#group. We do this to determine if </span>
    <span class="c1">#the non-majority cells could qualify</span>
    <span class="c1">#as a member of the majority group by</span>
    <span class="c1">#using a marker for cells of the </span>
    <span class="c1">#majority group.</span>
    <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">cell_types_in_group</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">belongs_to_group</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Are they </span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">?&quot;</span><span class="p">)</span>
        <span class="n">markers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_type_to_markers</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">marker</span> <span class="ow">in</span> <span class="n">markers</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_to_median_value</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span>
            <span class="n">marker_value</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="n">marker_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#Nothing to be done.</span>
                <span class="k">continue</span>

            <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_median_expression_from_indices</span><span class="p">(</span>
                <span class="n">marker</span><span class="p">,</span> <span class="n">cells</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">expression_value</span> <span class="o">=</span> <span class="n">x</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">marker_value</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="c1">#Let X be the mean/median expression </span>
            <span class="c1">#value of that marker for the</span>
            <span class="c1">#given minority.</span>
            <span class="c1">#Let Y be the mean/median expression</span>
            <span class="c1">#value of that same marker for</span>
            <span class="c1">#the cells in the sample that </span>
            <span class="c1">#are known to express that</span>
            <span class="c1">#marker. If X is above Y </span>
            <span class="c1">#multiplied by the conversion</span>
            <span class="c1">#threshold, then we add that</span>
            <span class="c1">#minority to the majority,</span>
            <span class="k">if</span> <span class="n">marker_value</span> <span class="o">*</span> <span class="n">conversion_threshold</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">belongs_to_group</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span><span class="s2">&quot;To convert.&quot;</span><span class="p">)</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="n">belongs_to_group</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">CA</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cells</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&gt;&gt;&gt;Cells do not belong to </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===============================&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
        </details>
    </div>

  </div>









  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.compute_partition_for_gen" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_partition_for_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.compute_partition_for_gen" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Compute the partition of the given set            of cells. The rows input             contains the indices of the             rows we are to partition.             The algorithm computes a truncated             SVD and the corresponding modularity             of the newly created communities.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_partition_for_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="c1">#) -&gt; tuple[float, np.ndarray]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the partition of the given set\</span>
<span class="sd">        of cells. The rows input \</span>
<span class="sd">        contains the indices of the \</span>
<span class="sd">        rows we are to partition. \</span>
<span class="sd">        The algorithm computes a truncated \</span>
<span class="sd">        SVD and the corresponding modularity \</span>
<span class="sd">        of the newly created communities.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_mode</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;I was given: </span><span class="si">{</span><span class="n">rows</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">partition</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> 
    <span class="c1">#print(f&quot;Number of cells: {n_rows}&quot;)</span>

    <span class="c1">#If the number of rows is less than 3,</span>
    <span class="c1">#we keep the cluster as it is.</span>
    <span class="k">if</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

    <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">rows</span><span class="p">)]</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_rows</span><span class="p">)</span>
    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ones</span><span class="p">)</span>
    <span class="n">row_sums_mtx</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span>
    <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">row_sums_mtx</span> <span class="o">-</span> <span class="n">S</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_rows</span>

    <span class="n">zero_row_sums_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">has_zero_row_sums</span> <span class="o">=</span> <span class="n">zero_row_sums_mask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="n">has_neg_row_sums</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_sums</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 

    <span class="k">if</span> <span class="n">has_zero_row_sums</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We have zero row sums.&quot;</span><span class="p">)</span>
        <span class="n">row_sums</span><span class="p">[</span><span class="n">zero_row_sums_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">has_neg_row_sums</span> <span class="ow">and</span> <span class="n">has_zero_row_sums</span><span class="p">:</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This matrix cannot be processed.&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;Cannot have negative and zero row sums.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">has_neg_row_sums</span><span class="p">:</span>
        <span class="c1">#This is a very expensive operation</span>
        <span class="c1">#since it computes all the eigenvectors.</span>
        <span class="k">if</span> <span class="mi">5000</span> <span class="o">&lt;</span> <span class="n">n_rows</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The row sums are negative.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We will use a full eigen decomp.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The block size is </span><span class="si">{</span><span class="n">n_rows</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning ...&quot;</span><span class="p">)</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This operation is very expensive.&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">row_sums</span>
        <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">inv_row_sums</span><span class="p">)</span>
        <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">inv_row_sums</span> <span class="o">@</span> <span class="n">laplacian_mtx</span>
        <span class="n">eig_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">)</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvalues</span>
        <span class="n">eig_vecs</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvectors</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vecs</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#Nonnegative row sums.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">E_obj</span> <span class="o">=</span> <span class="n">Eigen_Hermitian</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">,</span>
                                    <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="n">M</span><span class="o">=</span><span class="n">row_sums_mtx</span><span class="p">,</span>
                                    <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">which</span><span class="o">=</span><span class="s2">&quot;LM&quot;</span><span class="p">)</span>
            <span class="n">eigen_val_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">E_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1">#Identify the eigenvalue with the</span>
            <span class="c1">#largest magnitude.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">eigen_val_abs</span><span class="p">)</span>
            <span class="c1">#Choose the eigenvector corresponding</span>
            <span class="c1"># to the eigenvalue with the </span>
            <span class="c1"># largest magnitude.</span>
            <span class="n">eigen_vectors</span> <span class="o">=</span> <span class="n">E_obj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">eigen_vectors</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="c1">#This is a very expensive operation</span>
            <span class="c1">#since it computes all the eigenvectors.</span>
            <span class="k">if</span> <span class="mi">5000</span> <span class="o">&lt;</span> <span class="n">n_rows</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We will use a full eigen decomp.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The block size is </span><span class="si">{</span><span class="n">n_rows</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning ...&quot;</span><span class="p">)</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This operation is very expensive.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">row_sums</span>
            <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">inv_row_sums</span><span class="p">)</span>
            <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">inv_row_sums</span> <span class="o">@</span> <span class="n">laplacian_mtx</span>
            <span class="n">eig_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">)</span>
            <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvalues</span>
            <span class="n">eig_vecs</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvectors</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)))</span>
            <span class="c1">#Get the index of the second smallest </span>
            <span class="c1">#eigenvalue.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vecs</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="p">))</span>


    <span class="n">mask_c1</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">W</span>
    <span class="n">mask_c2</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask_c1</span>

    <span class="c1">#If one partition has all the elements</span>
    <span class="c1">#then return with Q = 0.</span>
    <span class="k">if</span> <span class="n">mask_c1</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span> <span class="n">mask_c2</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

    <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">mask_c1</span><span class="p">,</span> <span class="n">mask_c2</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">:</span>
        <span class="n">n_rows_msk</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">partition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="n">ones_msk</span> <span class="o">=</span> <span class="n">ones</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">row_sums_msk</span> <span class="o">=</span> <span class="n">S</span> <span class="o">@</span> <span class="n">ones_msk</span>
        <span class="n">O_c</span> <span class="o">=</span> <span class="n">ones_msk</span> <span class="o">@</span> <span class="n">row_sums_msk</span> <span class="o">-</span> <span class="n">n_rows_msk</span>
        <span class="n">L_c</span> <span class="o">=</span> <span class="n">ones_msk</span> <span class="o">@</span> <span class="n">row_sums</span>  <span class="o">-</span> <span class="n">n_rows_msk</span>
        <span class="n">Q</span> <span class="o">+=</span> <span class="n">O_c</span> <span class="o">/</span> <span class="n">L</span> <span class="o">-</span> <span class="p">(</span><span class="n">L_c</span> <span class="o">/</span> <span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_mode</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Q</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;I found: </span><span class="si">{</span><span class="n">partition</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;===========================&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.compute_partition_for_sp" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_partition_for_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.compute_partition_for_sp" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Compute the partition of the given set            of cells. The rows input             contains the indices of the             rows we are to partition.             The algorithm computes a truncated             SVD and the corresponding modularity             of the newly created communities.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_partition_for_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="c1">#) -&gt; tuple[float, np.ndarray]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the partition of the given set\</span>
<span class="sd">        of cells. The rows input \</span>
<span class="sd">        contains the indices of the \</span>
<span class="sd">        rows we are to partition. \</span>
<span class="sd">        The algorithm computes a truncated \</span>
<span class="sd">        SVD and the corresponding modularity \</span>
<span class="sd">        of the newly created communities.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_mode</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;I was given: </span><span class="si">{</span><span class="n">rows</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">partition</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> 
    <span class="c1">#print(f&quot;Number of cells: {n_rows}&quot;)</span>

    <span class="c1">#If the number of rows is less than 3,</span>
    <span class="c1">#we keep the cluster as it is.</span>
    <span class="k">if</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

    <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">rows</span><span class="p">,:]</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_rows</span><span class="p">)</span>
    <span class="n">partial_row_sums</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ones</span><span class="p">)</span>
    <span class="c1">#1^T @ B @ B^T @ 1 = (B^T @ 1)^T @ (B^T @ 1)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">partial_row_sums</span> <span class="o">@</span> <span class="n">partial_row_sums</span> <span class="o">-</span> <span class="n">n_rows</span>
    <span class="c1">#These are the row sums of the similarity matrix</span>
    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">B</span> <span class="o">@</span> <span class="n">partial_row_sums</span>
    <span class="c1">#Check if we have negative entries before computing</span>
    <span class="c1">#the square root.</span>
    <span class="c1"># if  neg_row_sums or self.use_eig_decomp:</span>
    <span class="n">zero_row_sums_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">has_zero_row_sums</span> <span class="o">=</span> <span class="n">zero_row_sums_mask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="n">has_neg_row_sums</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_sums</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 

    <span class="k">if</span> <span class="n">has_zero_row_sums</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We have zero row sums.&quot;</span><span class="p">)</span>
        <span class="n">row_sums</span><span class="p">[</span><span class="n">zero_row_sums_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">has_neg_row_sums</span> <span class="ow">and</span> <span class="n">has_zero_row_sums</span><span class="p">:</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This matrix cannot be processed.&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;Cannot have negative and zero row sums.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

    <span class="k">if</span>  <span class="n">has_neg_row_sums</span><span class="p">:</span>
        <span class="c1">#This means we cannot use the fast approach</span>
        <span class="c1">#We&#39;ll have to build a dense representation</span>
        <span class="c1"># of the similarity matrix.</span>
        <span class="k">if</span> <span class="mi">5000</span> <span class="o">&lt;</span> <span class="n">n_rows</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The row sums are negative.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We will use a full eigen decomp.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The block size is </span><span class="si">{</span><span class="n">n_rows</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning ...&quot;</span><span class="p">)</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This operation is very expensive.&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">B</span> <span class="o">@</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span>
        <span class="n">row_sums_mtx</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span>
        <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">row_sums_mtx</span> <span class="o">-</span> <span class="n">laplacian_mtx</span>

        <span class="c1">#This is a very expensive operation</span>
        <span class="c1">#since it computes all the eigenvectors.</span>
        <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">row_sums</span>
        <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">inv_row_sums</span><span class="p">)</span>
        <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">inv_row_sums</span> <span class="o">@</span> <span class="n">laplacian_mtx</span>
        <span class="n">eig_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">)</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvalues</span>
        <span class="n">eig_vecs</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvectors</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)))</span>
        <span class="c1">#Get the index of the second smallest eigenvalue.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vecs</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="p">))</span>

    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_eig_decomp</span> <span class="ow">or</span> <span class="n">has_zero_row_sums</span><span class="p">:</span>
        <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">B</span> <span class="o">@</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span>
        <span class="n">row_sums_mtx</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span>
        <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">row_sums_mtx</span> <span class="o">-</span> <span class="n">laplacian_mtx</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#if the row sums are negative, this </span>
            <span class="c1">#step could fail.</span>
            <span class="n">E_obj</span> <span class="o">=</span> <span class="n">Eigen_Hermitian</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">,</span>
                                    <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="n">M</span><span class="o">=</span><span class="n">row_sums_mtx</span><span class="p">,</span>
                                    <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">which</span><span class="o">=</span><span class="s2">&quot;LM&quot;</span><span class="p">)</span>
            <span class="n">eigen_val_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">E_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1">#Identify the eigenvalue with the</span>
            <span class="c1">#largest magnitude.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">eigen_val_abs</span><span class="p">)</span>
            <span class="c1">#Choose the eigenvector corresponding</span>
            <span class="c1"># to the eigenvalue with the </span>
            <span class="c1"># largest magnitude.</span>
            <span class="n">eigen_vectors</span> <span class="o">=</span> <span class="n">E_obj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">eigen_vectors</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1">#This is a very expensive operation</span>
            <span class="c1">#since it computes all the eigenvectors.</span>
            <span class="k">if</span> <span class="mi">5000</span> <span class="o">&lt;</span> <span class="n">n_rows</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We will use a full eigen decomp.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The block size is </span><span class="si">{</span><span class="n">n_rows</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning ...&quot;</span><span class="p">)</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;This operation is very expensive.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
            <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">row_sums</span>
            <span class="n">inv_row_sums</span>   <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">inv_row_sums</span><span class="p">)</span>
            <span class="n">laplacian_mtx</span>  <span class="o">=</span> <span class="n">inv_row_sums</span> <span class="o">@</span> <span class="n">laplacian_mtx</span>
            <span class="n">eig_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">laplacian_mtx</span><span class="p">)</span>
            <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvalues</span>
            <span class="n">eig_vecs</span> <span class="o">=</span> <span class="n">eig_obj</span><span class="o">.</span><span class="n">eigenvectors</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)))</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eig_vecs</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="p">))</span>


    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#This is the fast approach.</span>
        <span class="c1">#It is fast in the sense that the </span>
        <span class="c1">#operations are faster if the matrix</span>
        <span class="c1">#is sparse, i.e., O(n) nonzero entries.</span>

        <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">D</span> <span class="o">@</span> <span class="n">B</span>
        <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trunc_SVD</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">singular_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trunc_SVD</span><span class="o">.</span><span class="n">singular_values_</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">singular_values</span><span class="p">)</span>
        <span class="c1">#Get the singular vector corresponding to the</span>
        <span class="c1">#second largest singular value.</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>


    <span class="n">mask_c1</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">W</span>
    <span class="n">mask_c2</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask_c1</span>

    <span class="c1">#If one partition has all the elements</span>
    <span class="c1">#then return with Q = 0.</span>
    <span class="k">if</span> <span class="n">mask_c1</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span> <span class="n">mask_c2</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

    <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">mask_c1</span><span class="p">,</span> <span class="n">mask_c2</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">:</span>
        <span class="n">n_rows_msk</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">partition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="n">ones_msk</span> <span class="o">=</span> <span class="n">ones</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">row_sums_msk</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ones_msk</span><span class="p">)</span>
        <span class="n">O_c</span> <span class="o">=</span> <span class="n">row_sums_msk</span> <span class="o">@</span> <span class="n">row_sums_msk</span> <span class="o">-</span> <span class="n">n_rows_msk</span>
        <span class="n">L_c</span> <span class="o">=</span> <span class="n">ones_msk</span> <span class="o">@</span> <span class="n">row_sums</span>  <span class="o">-</span> <span class="n">n_rows_msk</span>
        <span class="n">Q</span> <span class="o">+=</span> <span class="n">O_c</span> <span class="o">/</span> <span class="n">L</span> <span class="o">-</span> <span class="p">(</span><span class="n">L_c</span> <span class="o">/</span> <span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_mode</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Q</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;I found: </span><span class="si">{</span><span class="n">partition</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;===========================&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.convert_graph_to_json" class="doc doc-heading">
<code class="highlight language-python"><span class="n">convert_graph_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.convert_graph_to_json" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>The graph structure stored in the attribute            self.J has to be formatted into a             JSON file. This function takes care            of that task. The output file is             named 'cluster_tree.json' and is            equivalent to the 'cluster_tree.json'            file produced by too-many-cells.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">convert_graph_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The graph structure stored in the attribute\</span>
<span class="sd">        self.J has to be formatted into a \</span>
<span class="sd">        JSON file. This function takes care\</span>
<span class="sd">        of that task. The output file is \</span>
<span class="sd">        named &#39;cluster_tree.json&#39; and is\</span>
<span class="sd">        equivalent to the &#39;cluster_tree.json&#39;\</span>
<span class="sd">        file produced by too-many-cells.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;cluster_tree.json&quot;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>
    <span class="n">replace_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39; &#39;</span><span class="p">:</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span><span class="s1">&#39;null&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">:</span><span class="s1">&#39;&quot;&#39;</span><span class="p">}</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">replace_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">regexp</span>  <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">replace_dict</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> 
    <span class="n">obj</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
        <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.convert_mm_from_source_to_anndata" class="doc doc-heading">
<code class="highlight language-python"><span class="n">convert_mm_from_source_to_anndata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.convert_mm_from_source_to_anndata" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>This function reads the matrix.mtx file                 located at the source directory.                Since we assume that the matrix                 has the format genes x cells, we                transpose the matrix, then                 convert it to the CSR format                 and then into an AnnData object.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">convert_mm_from_source_to_anndata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function reads the matrix.mtx file \</span>
<span class="sd">            located at the source directory.\</span>
<span class="sd">            Since we assume that the matrix \</span>
<span class="sd">            has the format genes x cells, we\</span>
<span class="sd">            transpose the matrix, then \</span>
<span class="sd">            convert it to the CSR format \</span>
<span class="sd">            and then into an AnnData object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading data from .mtx file.&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Note that we assume the format:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;genes=rows and cells=columns.&#39;</span><span class="p">)</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.mtx&#39;</span><span class="p">):</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">f</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;.mtx file not found.&#39;</span><span class="p">)</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">mmread</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="c1">#Remember that the input matrix has</span>
    <span class="c1">#genes for rows and cells for columns.</span>
    <span class="c1">#Thus, just transpose.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;barcodes.tsv&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">df_barcodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
            <span class="n">fname</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">barcodes</span> <span class="o">=</span> <span class="n">df_barcodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;genes.tsv&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">df_genes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
            <span class="n">fname</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">genes</span> <span class="o">=</span> <span class="n">df_genes</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">AnnData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs_names</span> <span class="o">=</span> <span class="n">barcodes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="n">genes</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Elapsed time for loading: &#39;</span> <span class="o">+</span> 
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.create_data_for_tmci" class="doc doc-heading">
<code class="highlight language-python"><span class="n">create_data_for_tmci</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmci_mtx_dir</span><span class="o">=</span><span class="s1">&#39;tmci_mtx_data&#39;</span><span class="p">,</span> <span class="n">list_of_genes</span><span class="o">=</span><span class="p">[],</span> <span class="n">path_to_genes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">create_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.create_data_for_tmci" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Produce the 10X files for a given set of            genes.  This function produces the            genes x cells matrix market format matrix,            the genes.tsv file and the barcodes.
If a path is provided for the genes, then the            first column of the csv file must have the            gene names.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">create_data_for_tmci</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tmci_mtx_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;tmci_mtx_data&quot;</span><span class="p">,</span>
        <span class="n">list_of_genes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">path_to_genes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">create_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produce the 10X files for a given set of\</span>
<span class="sd">        genes.  This function produces the\</span>
<span class="sd">        genes x cells matrix market format matrix,\</span>
<span class="sd">        the genes.tsv file and the barcodes.</span>
<span class="sd">    If a path is provided for the genes, then the\</span>
<span class="sd">        first column of the csv file must have the\</span>
<span class="sd">        gene names.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">tmci_mtx_dir</span><span class="p">)</span>

    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Genes</span>
    <span class="n">genes_f</span> <span class="o">=</span> <span class="s2">&quot;genes.tsv&quot;</span>
    <span class="n">genes_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">,</span> <span class="n">genes_f</span><span class="p">)</span>

    <span class="n">var_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">col_indices</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_to_genes</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path_to_genes</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">#The first column should contain the genes.</span>
        <span class="n">list_of_genes</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_genes</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">list_of_genes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gene</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">var_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>
            <span class="n">col_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>
            <span class="n">col_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_index</span><span class="p">)</span>

        <span class="n">G_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span><span class="n">col_indices</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#If not list is provided, use all the genes.</span>
        <span class="n">var_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">var_names</span>
        <span class="n">G_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">X</span>

    <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_names</span><span class="p">,</span><span class="n">var_names</span><span class="p">]</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
        <span class="n">genes_f</span><span class="p">,</span>
        <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Barcodes</span>
    <span class="n">barcodes_f</span> <span class="o">=</span> <span class="s2">&quot;barcodes.tsv&quot;</span>
    <span class="n">barcodes_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">,</span>
                              <span class="n">barcodes_f</span><span class="p">)</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs_names</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
        <span class="n">barcodes_f</span><span class="p">,</span>
        <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Matrix</span>
    <span class="k">if</span> <span class="n">create_matrix</span><span class="p">:</span>
        <span class="n">matrix_f</span> <span class="o">=</span> <span class="s2">&quot;matrix.mtx&quot;</span>
        <span class="n">matrix_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">,</span>
                                <span class="n">matrix_f</span><span class="p">)</span>
        <span class="n">mmwrite</span><span class="p">(</span><span class="n">matrix_f</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">G_mtx</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.estimate_n_of_iterations" class="doc doc-heading">
<code class="highlight language-python"><span class="n">estimate_n_of_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.estimate_n_of_iterations" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>We assume a model of the form         number_of_iter = const * N^exponent         where N is the number of cells.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_n_of_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    We assume a model of the form \</span>
<span class="sd">    number_of_iter = const * N^exponent \</span>
<span class="sd">    where N is the number of cells.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#Average number of cells per leaf node</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6681664297844971</span><span class="p">)</span>
    <span class="n">exponent</span> <span class="o">=</span> <span class="mf">0.86121348</span>
    <span class="c1">#exponent = 0.9</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">iter_estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span><span class="n">q2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">iter_estimates</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.generate_cell_annotation_file" class="doc doc-heading">
<code class="highlight language-python"><span class="n">generate_cell_annotation_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ann_col</span><span class="o">=</span><span class="s1">&#39;cell_annotations&#39;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;cell_annotation_labels&#39;</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.generate_cell_annotation_file" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>This function stores a CSV file with            the labels for each cell.</p>
<p>:param column: Name of the            column in the .obs data frame of            the AnnData object that contains            the labels to be used for the tree            visualization. For example, cell             types.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate_cell_annotation_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
        <span class="n">tag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;cell_annotation_labels&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function stores a CSV file with\</span>
<span class="sd">        the labels for each cell.</span>

<span class="sd">    :param column: Name of the\</span>
<span class="sd">        column in the .obs data frame of\</span>
<span class="sd">        the AnnData object that contains\</span>
<span class="sd">        the labels to be used for the tree\</span>
<span class="sd">        visualization. For example, cell \</span>
<span class="sd">        types.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tag</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;.csv&quot;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">tag</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cell_annotations_path</span> <span class="o">=</span> <span class="n">fname</span>

    <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cell_ann_col</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;item&#39;</span><span class="p">]</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.generate_matrix_from_signature_file" class="doc doc-heading">
<code class="highlight language-python"><span class="n">generate_matrix_from_signature_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signature_path</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.generate_matrix_from_signature_file" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Generate a matrix from the signature provided             through a file. The entries with a positive
    weight are assumed to be upregulated and             those with a negative weight are assumed             to be downregulated. The algorithm will             standardize the matrix, i.e., centering             and scaling.</p>
<p>If the signature has both positive and             negative weights, two versions will be             created. The unadjusted version simply             computes a weighted average using the             weights provided in the signature file.            In the adjusted version the weights             are adjusted to give equal weight to the             upregulated and downregulated genes.</p>
<p>Assumptions</p>
<p>We assume that the file has at least two             columns. One should be named "Gene" and             the other "Weight".             The count matrix has cells for rows and             genes for columns.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate_matrix_from_signature_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signature_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a matrix from the signature provided \</span>
<span class="sd">        through a file. The entries with a positive</span>
<span class="sd">        weight are assumed to be upregulated and \</span>
<span class="sd">        those with a negative weight are assumed \</span>
<span class="sd">        to be downregulated. The algorithm will \</span>
<span class="sd">        standardize the matrix, i.e., centering \</span>
<span class="sd">        and scaling.</span>

<span class="sd">    If the signature has both positive and \</span>
<span class="sd">        negative weights, two versions will be \</span>
<span class="sd">        created. The unadjusted version simply \</span>
<span class="sd">        computes a weighted average using the \</span>
<span class="sd">        weights provided in the signature file.\</span>
<span class="sd">        In the adjusted version the weights \</span>
<span class="sd">        are adjusted to give equal weight to the \</span>
<span class="sd">        upregulated and downregulated genes.</span>

<span class="sd">    Assumptions</span>

<span class="sd">    We assume that the file has at least two \</span>
<span class="sd">        columns. One should be named &quot;Gene&quot; and \</span>
<span class="sd">        the other &quot;Weight&quot;. \</span>
<span class="sd">        The count matrix has cells for rows and \</span>
<span class="sd">        genes for columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_signature</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">signature_path</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">Z</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">Z_is_sparse</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>

    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">up_reg</span> <span class="o">=</span> <span class="n">vec</span> <span class="o">*</span> <span class="mi">0</span>
    <span class="n">down_reg</span> <span class="o">=</span> <span class="n">vec</span> <span class="o">*</span> <span class="mi">0</span>

    <span class="n">up_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">up_weight</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">down_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">down_weight</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">df_signature</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">]</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">df_signature</span><span class="p">[</span><span class="s2">&quot;Weight&quot;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">gene</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gene</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Z</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">col_index</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Z_is_sparse</span><span class="p">:</span>
            <span class="n">gene_col</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="n">col_index</span><span class="p">)</span>
            <span class="n">gene_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">gene_col</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gene_col</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span><span class="n">col_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">:</span>
            <span class="n">up_reg</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">gene_col</span>
            <span class="n">up_weight</span> <span class="o">+=</span> <span class="n">weight</span>
            <span class="n">up_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">down_reg</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">gene_col</span>
            <span class="n">down_weight</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="n">down_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">total_counts</span> <span class="o">=</span> <span class="n">up_count</span> <span class="o">+</span> <span class="n">down_count</span>
    <span class="n">total_weight</span> <span class="o">=</span> <span class="n">up_weight</span> <span class="o">+</span> <span class="n">down_weight</span>

    <span class="n">list_of_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">list_of_gvecs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">UnAdjSign</span> <span class="o">=</span> <span class="n">up_reg</span> <span class="o">+</span> <span class="n">down_reg</span>
    <span class="n">UnAdjSign</span> <span class="o">/=</span> <span class="n">total_weight</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;UnAdjSign&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">UnAdjSign</span>
    <span class="n">list_of_gvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">UnAdjSign</span><span class="p">)</span>
    <span class="n">list_of_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;UnAdjSign&quot;</span><span class="p">)</span>

    <span class="n">up_factor</span> <span class="o">=</span> <span class="n">down_count</span> <span class="o">/</span> <span class="n">total_counts</span>
    <span class="n">down_factor</span> <span class="o">=</span> <span class="n">up_count</span> <span class="o">/</span> <span class="n">total_counts</span>

    <span class="n">modified_total_counts</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">up_count</span> <span class="o">*</span> <span class="n">down_count</span>
    <span class="n">modified_total_counts</span> <span class="o">/=</span> <span class="n">total_counts</span>

    <span class="n">check</span> <span class="o">=</span> <span class="n">up_factor</span><span class="o">*</span><span class="n">up_count</span> <span class="o">+</span> <span class="n">down_factor</span><span class="o">*</span><span class="n">down_count</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">up_count</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">down_count</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">total_counts</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">modified_total_counts</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">check</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">up_factor</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">down_factor</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="n">mixed_signs</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">up_count</span><span class="p">:</span>
        <span class="n">UpReg</span>   <span class="o">=</span> <span class="n">up_reg</span> <span class="o">/</span> <span class="n">up_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;UpReg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">UpReg</span>
        <span class="n">list_of_gvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">UpReg</span><span class="p">)</span>
        <span class="n">list_of_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;UpReg&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UpRegulated genes: stats&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;UpReg&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">mixed_signs</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">down_count</span><span class="p">:</span>
        <span class="n">DownReg</span>   <span class="o">=</span> <span class="n">down_reg</span> <span class="o">/</span> <span class="n">down_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;DownReg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DownReg</span>
        <span class="n">list_of_gvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DownReg</span><span class="p">)</span>
        <span class="n">list_of_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DownReg&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DownRegulated genes: stats&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;DownReg&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Note: In our representation, &quot;</span> 
               <span class="s2">&quot;the higher the value of a downregulated &quot;</span>
               <span class="s2">&quot;gene, the more downregulated it is.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mixed_signs</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">mixed_signs</span><span class="p">:</span>
        <span class="n">AdjSign</span>  <span class="o">=</span> <span class="n">up_factor</span> <span class="o">*</span> <span class="n">up_reg</span>
        <span class="n">AdjSign</span> <span class="o">+=</span> <span class="n">down_factor</span> <span class="o">*</span> <span class="n">down_reg</span>
        <span class="n">AdjSign</span> <span class="o">/=</span> <span class="n">modified_total_counts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;AdjSign&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">AdjSign</span>
        <span class="n">list_of_gvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AdjSign</span><span class="p">)</span>
        <span class="n">list_of_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;AdjSign&quot;</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">list_of_gvecs</span><span class="p">)</span>

    <span class="c1">#This function will produce the </span>
    <span class="c1">#barcodes.tsv and the genes.tsv file.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">create_data_for_tmci</span><span class="p">(</span>
        <span class="n">list_of_genes</span> <span class="o">=</span> <span class="n">list_of_names</span><span class="p">,</span>
        <span class="n">create_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


    <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">mtx_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">,</span> <span class="s2">&quot;matrix.mtx&quot;</span><span class="p">)</span>

    <span class="n">mmwrite</span><span class="p">(</span><span class="n">mtx_path</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.get_path_from_node_x_to_node_y" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_path_from_node_x_to_node_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.get_path_from_node_x_to_node_y" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>For a given pair of nodes x and y, we find the
path between those nodes.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_path_from_node_x_to_node_y</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a given pair of nodes x and y, we find the</span>
<span class="sd">    path between those nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_path</span><span class="p">,</span> <span class="n">x_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_from_root_to_node</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y_path</span><span class="p">,</span> <span class="n">y_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_from_root_to_node</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">x_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x_path</span><span class="p">)</span>
    <span class="n">y_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">y_path</span><span class="p">)</span>

    <span class="c1"># print(x_dist)</span>
    <span class="c1"># print(y_dist)</span>

    <span class="c1"># print(&quot;===========&quot;)</span>

    <span class="c1"># print(x_path)</span>
    <span class="c1"># print(y_path)</span>

    <span class="c1"># print(&quot;===========&quot;)</span>

    <span class="n">intersection</span> <span class="o">=</span> <span class="n">x_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">y_set</span><span class="p">)</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>
    <span class="n">n_intersection</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>

    <span class="n">pivot_node</span> <span class="o">=</span> <span class="n">x_path</span><span class="p">[</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>
    <span class="n">pivot_dist</span> <span class="o">=</span> <span class="n">x_dist</span><span class="p">[</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>

    <span class="n">x_path</span> <span class="o">=</span> <span class="n">x_path</span><span class="p">[:</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>
    <span class="n">y_path</span> <span class="o">=</span> <span class="n">y_path</span><span class="p">[:</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>
    <span class="n">y_path</span> <span class="o">=</span> <span class="n">y_path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">x_dist</span> <span class="o">=</span> <span class="n">x_dist</span><span class="p">[:</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>
    <span class="n">y_dist</span> <span class="o">=</span> <span class="n">y_dist</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="n">n_intersection</span><span class="p">]</span>
    <span class="n">y_dist</span> <span class="o">=</span> <span class="n">y_dist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">full_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x_path</span><span class="p">,</span><span class="n">pivot_node</span><span class="p">,</span><span class="n">y_path</span><span class="p">))</span>
    <span class="n">full_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">x_dist</span><span class="p">,</span> <span class="n">pivot_dist</span><span class="p">,</span> <span class="n">pivot_dist</span><span class="p">,</span> <span class="n">y_dist</span><span class="p">))</span>
    <span class="n">full_dist</span> <span class="o">=</span> <span class="n">full_dist</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

    <span class="c1"># print(full_path) </span>
    <span class="c1"># print(full_dist)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="n">full_dist</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.get_path_from_root_to_node" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_path_from_root_to_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.get_path_from_root_to_node" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>For a given node, we find the path from the root 
to that node.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_path_from_root_to_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a given node, we find the path from the root </span>
<span class="sd">    to that node.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">target</span>
    <span class="n">path_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="n">modularity_vec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">node</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Get an iterator for the predecessors.</span>
        <span class="c1"># There should only be one predecessor.</span>
        <span class="n">predecessors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">predecessors</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">_node</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;Q&quot;</span><span class="p">]</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="n">path_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">modularity_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

    <span class="c1"># We assume that the distance between two children</span>
    <span class="c1"># nodes is equal to the modularity of the parent node.</span>
    <span class="c1"># Hence, the distance from a child to a parent is </span>
    <span class="c1"># half the modularity.</span>
    <span class="n">modularity_vec</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">modularity_vec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">path_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path_vec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">path_vec</span><span class="p">,</span> <span class="n">modularity_vec</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.load_cluster_info" class="doc doc-heading">
<code class="highlight language-python"><span class="n">load_cluster_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_file_path</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.load_cluster_info" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Load the cluster file.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">load_cluster_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cluster_file_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load the cluster file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>

    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_file_path</span><span class="p">):</span>
        <span class="n">cluster_fname</span> <span class="o">=</span> <span class="n">cluster_file_path</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;clusters.csv&#39;</span>
        <span class="n">cluster_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cluster_fname</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;File does not exists.&quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">cluster_fname</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">])</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.load_graph" class="doc doc-heading">
<code class="highlight language-python"><span class="n">load_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dot_fname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.load_graph" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Load the dot file.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">load_graph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dot_fname</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load the dot file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dot_fname</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;graph.dot&#39;</span>
        <span class="n">dot_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dot_fname</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;File does not exists.&quot;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">nx_agraph</span><span class="o">.</span><span class="n">read_dot</span><span class="p">(</span><span class="n">dot_fname</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>
    <span class="n">n_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>

    <span class="c1"># Change string labels to integers.</span>
    <span class="n">D</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">):</span>
        <span class="n">D</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">k</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># self.G = nx.convert_node_labels_to_integers(self.G)</span>
    <span class="c1"># Changing the labels to integers using the above </span>
    <span class="c1"># function follows a different numbering scheme to </span>
    <span class="c1"># that given by the labels of the node.</span>

    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.normalize_dense_rows" class="doc doc-heading">
<code class="highlight language-python"><span class="n">normalize_dense_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.normalize_dense_rows" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Divide each row of the count matrix by the             given norm. Note that this function             assumes that the matrix is dense.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">normalize_dense_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Divide each row of the count matrix by the \</span>
<span class="sd">        given norm. Note that this function \</span>
<span class="sd">        assumes that the matrix is dense.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Normalizing rows.&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">row</span><span class="p">,</span>
                              <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">similarity_norm</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.normalize_sparse_rows" class="doc doc-heading">
<code class="highlight language-python"><span class="n">normalize_sparse_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.normalize_sparse_rows" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Divide each row of the count matrix by the             given norm. Note that this function             assumes that the matrix is in the             compressed sparse row format.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">normalize_sparse_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Divide each row of the count matrix by the \</span>
<span class="sd">        given norm. Note that this function \</span>
<span class="sd">        assumes that the matrix is in the \</span>
<span class="sd">        compressed sparse row format.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Normalizing rows.&quot;</span><span class="p">)</span>


    <span class="c1">#It&#39;s just an alias.</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">getrow</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">data</span>
        <span class="n">row_norm</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
            <span class="n">nz</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">similarity_norm</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">nz</span> <span class="o">/</span> <span class="n">row_norm</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mat</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">mat</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">row</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.plot_expression_from_node_x_to_node_y" class="doc doc-heading">
<code class="highlight language-python"><span class="n">plot_expression_from_node_x_to_node_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">genes</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.plot_expression_from_node_x_to_node_y" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>For a given pair of nodes x and y, we compute the             gene expression path along the path connecting            those nodes.
Make sure that property set_of_leaf_nodes is            populated with the correct information.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">plot_expression_from_node_x_to_node_y</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">genes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a given pair of nodes x and y, we compute the \</span>
<span class="sd">        gene expression path along the path connecting\</span>
<span class="sd">        those nodes.</span>
<span class="sd">    Make sure that property set_of_leaf_nodes is\</span>
<span class="sd">        populated with the correct information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">genes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">list_of_genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">genes</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_of_genes</span> <span class="o">=</span> <span class="n">genes</span>

    <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_from_node_x_to_node_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="n">path_vec</span><span class="p">,</span> <span class="n">dist_vec</span> <span class="o">=</span> <span class="n">T</span>
    <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_vec</span><span class="p">)</span>
    <span class="n">n_genes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_genes</span><span class="p">)</span>
    <span class="n">exp_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_genes</span><span class="p">,</span><span class="n">n_nodes</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">col</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path_vec</span><span class="p">):</span>
        <span class="n">g_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_cluster_mean_expression</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">list_of_genes</span><span class="p">)</span>
        <span class="n">exp_mat</span><span class="p">[:,</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_exp</span>

    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

    <span class="c1"># bogus_names = [&quot;Gene A&quot;, &quot;Gene B&quot;]</span>
    <span class="c1"># colors = [&quot;blue&quot;, &quot;red&quot;]</span>

    <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">gene</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_genes</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">,</span>
                <span class="n">exp_mat</span><span class="p">[</span><span class="n">row</span><span class="p">,:],</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">gene</span><span class="p">,</span>
                <span class="c1"># label=bogus_names[row],</span>
                <span class="c1"># color = colors[row]</span>
                <span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;From node </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> to node </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="c1"># txt = f&quot;From node X to node Y&quot;</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Gene expression&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Distance (modularity units)&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;sci&#39;</span><span class="p">,</span>
                         <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
                         <span class="n">scilimits</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;expression_path.pdf&quot;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Plot has been generated.&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.reverse_path" class="doc doc-heading">
<code class="highlight language-python"><span class="n">reverse_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.reverse_path" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>This function reverses the path from the root        node to the leaf node.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">reverse_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function reverses the path from the root\</span>
<span class="sd">    node to the leaf node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reversed_p</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">reversed_p</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.run_spectral_clustering" class="doc doc-heading">
<code class="highlight language-python"><span class="n">run_spectral_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift_similarity_matrix</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">normalize_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">similarity_function</span><span class="o">=</span><span class="s1">&#39;cosine_sparse&#39;</span><span class="p">,</span> <span class="n">similarity_norm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">similarity_power</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">similarity_gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_eig_decomp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_tf_idf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tf_idf_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tf_idf_smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">svd_algorithm</span><span class="o">=</span><span class="s1">&#39;randomized&#39;</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.run_spectral_clustering" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>This function computes the partitions of the                 initial cell population and continues                 until the modularity of the newly                 created partitions is nonpositive.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">run_spectral_clustering</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shift_similarity_matrix</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">normalize_rows</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">similarity_function</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;cosine_sparse&quot;</span><span class="p">,</span>
        <span class="n">similarity_norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">similarity_power</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">similarity_gamma</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_eig_decomp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_tf_idf</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">tf_idf_norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tf_idf_smooth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">svd_algorithm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;randomized&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes the partitions of the \</span>
<span class="sd">            initial cell population and continues \</span>
<span class="sd">            until the modularity of the newly \</span>
<span class="sd">            created partitions is nonpositive.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">svd_algorithms</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;randomized&quot;</span><span class="p">,</span><span class="s2">&quot;arpack&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">svd_algorithm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">svd_algorithms</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected SVD algorithm.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">similarity_norm</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected similarity norm.&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">similarity_norm</span> <span class="o">=</span> <span class="n">similarity_norm</span>

    <span class="k">if</span> <span class="n">similarity_gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># gamma = 1 / (number of features)</span>
        <span class="n">similarity_gamma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">similarity_gamma</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected similarity gamma.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">similarity_power</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected similarity power.&quot;</span><span class="p">)</span>

    <span class="n">similarity_functions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;cosine_sparse&quot;</span><span class="p">)</span>
    <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;cosine&quot;</span><span class="p">)</span>
    <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;neg_exp&quot;</span><span class="p">)</span>
    <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;laplacian&quot;</span><span class="p">)</span>
    <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span>
    <span class="n">similarity_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;div_by_sum&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">similarity_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">similarity_functions</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected similarity fun.&quot;</span><span class="p">)</span>


    <span class="c1">#In case the user wants to call this function again.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">spectral_clustering_has_been_called</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1">#TF-IDF section</span>
    <span class="k">if</span> <span class="n">use_tf_idf</span><span class="p">:</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using inverse document frequency (IDF).&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tf_idf_norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using term frequency normalization.&quot;</span><span class="p">)</span>
            <span class="n">tf_idf_norms</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;l2&quot;</span><span class="p">,</span><span class="s2">&quot;l1&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">tf_idf_norm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tf_idf_norms</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected tf norm.&quot;</span><span class="p">)</span>

        <span class="n">tf_idf_obj</span> <span class="o">=</span> <span class="n">TfidfTransformer</span><span class="p">(</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">tf_idf_norm</span><span class="p">,</span>
            <span class="n">smooth_idf</span><span class="o">=</span><span class="n">tf_idf_smooth</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">tf_idf_obj</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#If the matrix was originally dense</span>
            <span class="c1">#and the tf_idf function changed it</span>
            <span class="c1">#to sparse, then convert to dense.</span>
            <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

        <span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Elapsed time for IDF build: &quot;</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

    <span class="c1">#Normalization section</span>
    <span class="n">use_cos_sp</span> <span class="o">=</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine_sparse&quot;</span>
    <span class="n">use_dbs</span> <span class="o">=</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;div_by_sum&quot;</span>
    <span class="k">if</span> <span class="n">normalize_rows</span> <span class="ow">or</span> <span class="n">use_cos_sp</span> <span class="ow">or</span> <span class="n">use_dbs</span><span class="p">:</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalize_sparse_rows</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalize_dense_rows</span><span class="p">()</span>

        <span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Elapsed time for normalization: &quot;</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

    <span class="c1">#Similarity section.</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working with </span><span class="si">{</span><span class="n">similarity_function</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine_sparse&quot;</span><span class="p">:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trunc_SVD</span> <span class="o">=</span> <span class="n">TruncatedSVD</span><span class="p">(</span>
                <span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">n_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="n">algorithm</span><span class="o">=</span><span class="n">svd_algorithm</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#Use a similarity function different from</span>
        <span class="c1">#the cosine_sparse similarity function.</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building similarity matrix ...&quot;</span><span class="p">)</span>
        <span class="n">n_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">max_workers</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="n">n_workers</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">8</span> <span class="o">&lt;</span> <span class="n">max_workers</span><span class="p">:</span>
                <span class="n">n_workers</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">elif</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="mi">50000</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">16</span> <span class="o">&lt;</span> <span class="n">max_workers</span><span class="p">:</span>
                <span class="n">n_workers</span> <span class="o">=</span> <span class="mi">16</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">25</span> <span class="o">&lt;</span> <span class="n">max_workers</span><span class="p">:</span>
                <span class="n">n_workers</span> <span class="o">=</span> <span class="mi">25</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using </span><span class="si">{</span><span class="n">n_workers</span><span class="si">=}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine_sparse&quot;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine&quot;</span><span class="p">:</span>
        <span class="c1">#( x @ y ) / ( ||x|| * ||y|| )</span>
        <span class="k">def</span> <span class="nf">sim_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="n">cos_sim</span> <span class="o">=</span> <span class="n">x</span> <span class="o">@</span> <span class="n">y</span>
            <span class="n">x_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">y_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cos_sim</span> <span class="o">/=</span> <span class="p">(</span><span class="n">x_norm</span> <span class="o">*</span> <span class="n">y_norm</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cos_sim</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">pairwise_kernels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;cosine&quot;</span><span class="p">,</span>
                                    <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;neg_exp&quot;</span><span class="p">:</span>
        <span class="c1">#exp(-||x-y||^power * gamma)</span>
        <span class="k">def</span> <span class="nf">sim_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">similarity_norm</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">similarity_power</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">delta</span> <span class="o">*</span> <span class="n">similarity_gamma</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">pairwise_kernels</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">sim_fun</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;laplacian&quot;</span><span class="p">:</span>
        <span class="c1">#exp(-||x-y||^power * gamma)</span>
        <span class="k">def</span> <span class="nf">sim_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">delta</span> <span class="o">*</span> <span class="n">similarity_gamma</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">pairwise_kernels</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;laplacian&quot;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_workers</span><span class="p">,</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">similarity_gamma</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
        <span class="c1">#exp(-||x-y||^power * gamma)</span>
        <span class="k">def</span> <span class="nf">sim_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">delta</span> <span class="o">*</span> <span class="n">similarity_gamma</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">pairwise_kernels</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;rbf&quot;</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_workers</span><span class="p">,</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">similarity_gamma</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;div_by_sum&quot;</span><span class="p">:</span>
        <span class="c1">#1 - ( ||x-y|| / (||x|| + ||y||) )^power</span>
        <span class="c1">#The rows should have been previously normalized.</span>
        <span class="k">def</span> <span class="nf">sim_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">similarity_norm</span><span class="p">)</span>
            <span class="n">x_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">similarity_norm</span><span class="p">)</span>
            <span class="n">y_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">similarity_norm</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">/=</span> <span class="p">(</span><span class="n">x_norm</span> <span class="o">+</span> <span class="n">y_norm</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span>  <span class="mi">1</span> <span class="o">-</span> <span class="n">delta</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">similarity_norm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lp_norm</span> <span class="o">=</span> <span class="s2">&quot;l1&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">similarity_norm</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">lp_norm</span> <span class="o">=</span> <span class="s2">&quot;l2&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;Similarity norm should be 1 or 2.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                                    <span class="n">metric</span><span class="o">=</span><span class="n">lp_norm</span><span class="p">,</span>
                                    <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">similarity_function</span> <span class="o">!=</span> <span class="s2">&quot;cosine_sparse&quot;</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">shift_similarity_matrix</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Similarity matrix will be shifted.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shift: </span><span class="si">{</span><span class="n">shift_similarity_matrix</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">+=</span> <span class="n">shift_similarity_matrix</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Similarity matrix has been built.&quot;</span><span class="p">)</span>
        <span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="n">delta</span> <span class="o">/=</span> <span class="mi">60</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Elapsed time for similarity build: &quot;</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> minutes.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>


    <span class="bp">self</span><span class="o">.</span><span class="n">use_eig_decomp</span> <span class="o">=</span> <span class="n">use_eig_decomp</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>

    <span class="c1">#===========================================</span>
    <span class="c1">#=============Main=Loop=====================</span>
    <span class="c1">#===========================================</span>
    <span class="n">node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_counter</span>

    <span class="c1">#Initialize the array of cells to partition</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1">#Initialize the deque</span>
    <span class="c1"># self.DQ.append((rows, None))</span>
    <span class="c1"># self.DQ.append(rows)</span>

    <span class="c1">#Initialize the graph</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">))</span>

    <span class="c1">#Path to reach root node.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_to_path</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

    <span class="c1">#Indices to reach root node.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_to_j_index</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

    <span class="c1">#Update the node counter</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1">#============STEP=1================Cluster(0)</span>

    <span class="n">p_node_id</span> <span class="o">=</span> <span class="n">node_id</span>

    <span class="k">if</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine_sparse&quot;</span><span class="p">:</span>
        <span class="n">Q</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_partition_for_sp</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Q</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_partition_for_gen</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="n">Q</span><span class="p">:</span>
        <span class="c1">#Modularity is above threshold, and</span>
        <span class="c1">#thus each partition will be </span>
        <span class="c1">#inserted into the deque.</span>

        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modularity_to_json</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

        <span class="c1">#Update json index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1"># self.J.append([[],[]])</span>
        <span class="c1"># j_index = (1,)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;Q&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span>

        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">p_node_id</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">DQ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#Modularity is below threshold and </span>
        <span class="c1">#therefore this partition will not</span>
        <span class="c1">#be considered.</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;All cells belong&quot;</span> 
                <span class="s2">&quot; to the same partition.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">max_n_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_n_of_iterations</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">print_message_before_clustering</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">max_n_iter</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
        <span class="k">while</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DQ</span><span class="p">):</span>

            <span class="c1">#Get the rows corresponding to the</span>
            <span class="c1">#partition and the (parent) node</span>
            <span class="c1">#that produced such partition.</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">p_node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DQ</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="c1">#This id is for the new node.</span>
            <span class="n">node_id</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># For every cluster of cells that is popped</span>
            <span class="c1"># from the deque, we update the node_id. </span>
            <span class="c1"># If the cluster is further partitioned we </span>
            <span class="c1"># will store each partition but will not </span>
            <span class="c1"># assign node numbers. Node numbers will </span>
            <span class="c1"># only be assigned after being popped from </span>
            <span class="c1"># the deque.</span>

            <span class="c1"># We need to know the modularity to </span>
            <span class="c1"># determine if the node will </span>
            <span class="k">if</span> <span class="n">similarity_function</span> <span class="o">==</span> <span class="s2">&quot;cosine_sparse&quot;</span><span class="p">:</span>
                <span class="n">Q</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_partition_for_sp</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Q</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_partition_for_gen</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

            <span class="c1"># If the parent node is 0, then the path is</span>
            <span class="c1"># &quot;0&quot;.</span>
            <span class="n">current_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_path</span><span class="p">[</span><span class="n">p_node_id</span><span class="p">]</span>

            <span class="c1">#Update path for the new node</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="n">current_path</span> 
            <span class="n">new_path</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">node_to_path</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="o">=</span><span class="n">new_path</span>

            <span class="c1"># If the parent node is 0, then j_index is</span>
            <span class="c1"># (1,)</span>
            <span class="n">j_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_j_index</span><span class="p">[</span><span class="n">p_node_id</span><span class="p">]</span>

            <span class="n">n_stored_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c1">#Update the j_index. For example, if</span>
            <span class="c1">#j_index = (1,) and no blocks have been</span>
            <span class="c1">#stored, then the new j_index is (1,0).</span>
            <span class="c1">#Otherwise, it is (1,1).</span>
            <span class="n">j_index</span> <span class="o">+=</span> <span class="p">(</span><span class="n">n_stored_blocks</span><span class="p">,)</span>

            <span class="c1">#Include new node into the graph.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">))</span>

            <span class="c1">#Include new edge into the graph.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">p_node_id</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="n">Q</span><span class="p">:</span>
                <span class="c1">#Modularity is above threshold, and</span>
                <span class="c1">#thus each partition will be </span>
                <span class="c1">#inserted into the deque.</span>

                <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modularity_to_json</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">j_index</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

                <span class="c1"># We only store the modularity of nodes</span>
                <span class="c1"># whose modularity is above threshold.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;Q&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span>

                <span class="c1"># Update the j_index for the newly </span>
                <span class="c1"># created node. (1,0,1)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_to_j_index</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">j_index</span>

                <span class="c1"># Append each partition to the deque.</span>
                <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                    <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">DQ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#Modularity is below threshold and </span>
                <span class="c1">#therefore this partition will not</span>
                <span class="c1">#be considered.</span>

                <span class="c1">#Update the relation between a set of</span>
                <span class="c1">#cells and the corresponding leaf node.</span>
                <span class="c1">#Also include the path to reach that node.</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_column_index</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_id</span>

                <span class="n">reversed_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_path</span><span class="p">(</span>
                    <span class="n">new_path</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_column_index</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reversed_path</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">set_of_leaf_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

                <span class="c1">#Update the JSON structure for </span>
                <span class="c1">#a leaf node.</span>
                <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells_to_json</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">j_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

        <span class="c1">#==============END OF WHILE==============</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">pbar</span><span class="o">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_n_iter</span> <span class="o">=</span> <span class="n">pbar</span><span class="o">.</span><span class="n">n</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">delta_clustering</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">delta_clustering</span> <span class="o">/=</span> <span class="mi">60</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Elapsed time for clustering: &quot;</span> <span class="o">+</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_clustering</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> minutes.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.store_outputs" class="doc doc-heading">
<code class="highlight language-python"><span class="n">store_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ann_col</span><span class="o">=</span><span class="s1">&#39;cell_annotations&#39;</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.store_outputs" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Store the outputs and plot the branching tree.</p>
<p>File outputs:</p>
<p>cluster_list.json: The json file containing a list 
of clusters. </p>
<p>cluster_tree.json: The json file containing the 
output tree in a recursive format.</p>
<p>graph.dot: A dot file of the tree. It includes the 
modularity and the size.</p>
<p>node_info.csv: Size and modularity of each node.</p>
<p>clusters.csv: The cluster membership for each cell.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">store_outputs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cell_ann_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Store the outputs and plot the branching tree.</span>

<span class="sd">    File outputs:</span>

<span class="sd">    cluster_list.json: The json file containing a list </span>
<span class="sd">    of clusters. </span>

<span class="sd">    cluster_tree.json: The json file containing the </span>
<span class="sd">    output tree in a recursive format.</span>

<span class="sd">    graph.dot: A dot file of the tree. It includes the </span>
<span class="sd">    modularity and the size.</span>

<span class="sd">    node_info.csv: Size and modularity of each node.</span>

<span class="sd">    clusters.csv: The cluster membership for each cell.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>


    <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;graph.dot&#39;</span>
    <span class="n">dot_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

    <span class="n">nx</span><span class="o">.</span><span class="n">nx_agraph</span><span class="o">.</span><span class="n">write_dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">dot_fname</span><span class="p">)</span>
    <span class="c1">#Write cell to node data frame.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">write_cell_assignment_to_csv</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">convert_graph_to_json</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">write_cluster_list_to_json</span><span class="p">()</span>

    <span class="c1">#Store the cell annotations in the output folder.</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ann_col</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cell_ann_col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generate_cell_annotation_file</span><span class="p">(</span>
                <span class="n">cell_ann_col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;Annotation column does not exists.&quot;</span>
            <span class="c1">#raise ValueError(txt)</span>

    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>

    <span class="c1">#Number of cells for each node</span>
    <span class="n">size_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#Modularity for each node</span>
    <span class="n">Q_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#Node label</span>
    <span class="n">node_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">size_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;Q&#39;</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
            <span class="n">Q_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;Q&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Q_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1">#Write node information to CSV</span>
    <span class="n">D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_list</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span><span class="n">size_list</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">:</span><span class="n">Q_list</span><span class="p">}</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;node_info.csv&#39;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_twopi_cmd</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_radial_tree_from_dot_file</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Elapsed time for storing outputs: &#39;</span> <span class="o">+</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.update_cell_annotations" class="doc doc-heading">
<code class="highlight language-python"><span class="n">update_cell_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="s1">&#39;cell_annotations&#39;</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.update_cell_annotations" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Insert a column of cell annotations in the         AnnData.obs data frame. The column in the         data frame should be called "label". The         name of the column in the AnnData.obs         data frame is provided by the user through         the column argument.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">update_cell_annotations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cell_annotations&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert a column of cell annotations in the \</span>
<span class="sd">    AnnData.obs data frame. The column in the \</span>
<span class="sd">    data frame should be called &quot;label&quot;. The \</span>
<span class="sd">    name of the column in the AnnData.obs \</span>
<span class="sd">    data frame is provided by the user through \</span>
<span class="sd">    the column argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing label column.&quot;</span><span class="p">)</span>

    <span class="c1">#Reindex the data frame.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data frame size mismatch.&quot;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span>  <span class="n">df</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.visualize_with_tmc_interactive" class="doc doc-heading">
<code class="highlight language-python"><span class="n">visualize_with_tmc_interactive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_tmc_interactive</span><span class="p">,</span> <span class="n">use_column_for_labels</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">9991</span><span class="p">,</span> <span class="n">include_matrix_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmci_mtx_dir</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.visualize_with_tmc_interactive" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>This function produces a visualization                using too-many-cells-interactive.</p>
<p>:param path_to_tmc_interactive: Path to                 the too-many-cells-interactive                 directory.
:param use_column_for_labels: Name of the                column in the .obs data frame of                the AnnData object that contains                the labels to be used in the tree                visualization. For example, cell                 types.
:param port: Port to be used to open                the app in your browser using                the address localhost:port.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_with_tmc_interactive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">path_to_tmc_interactive</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">use_column_for_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">port</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9991</span><span class="p">,</span>
        <span class="n">include_matrix_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">tmci_mtx_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function produces a visualization\</span>
<span class="sd">            using too-many-cells-interactive.</span>

<span class="sd">    :param path_to_tmc_interactive: Path to \</span>
<span class="sd">            the too-many-cells-interactive \</span>
<span class="sd">            directory.</span>
<span class="sd">    :param use_column_for_labels: Name of the\</span>
<span class="sd">            column in the .obs data frame of\</span>
<span class="sd">            the AnnData object that contains\</span>
<span class="sd">            the labels to be used in the tree\</span>
<span class="sd">            visualization. For example, cell \</span>
<span class="sd">            types.</span>
<span class="sd">    :param port: Port to be used to open\</span>
<span class="sd">            the app in your browser using\</span>
<span class="sd">            the address localhost:port.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;cluster_tree.json&quot;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">tree_path</span> <span class="o">=</span> <span class="n">fname</span>
    <span class="n">port_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>


    <span class="n">bash_exec</span> <span class="o">=</span> <span class="s2">&quot;./start-and-load.sh&quot;</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">use_column_for_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">label_path_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">label_path</span>     <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_cell_annotation_file</span><span class="p">(</span>
                <span class="n">use_column_for_labels</span><span class="p">)</span>
        <span class="n">label_path_str</span> <span class="o">=</span> <span class="s2">&quot;--label-path&quot;</span>
        <span class="n">label_path</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_annotations_path</span>

    <span class="k">if</span> <span class="n">include_matrix_data</span><span class="p">:</span>
        <span class="n">matrix_path_str</span> <span class="o">=</span> <span class="s2">&quot;--matrix-dir&quot;</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmci_mtx_dir</span><span class="p">):</span>
            <span class="n">matrix_dir</span> <span class="o">=</span> <span class="n">tmci_mtx_dir</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No path for TMCI mtx.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating TMCI mtx data.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_data_for_tmci</span><span class="p">()</span>

            <span class="n">matrix_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmci_mtx_dir</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">matrix_path_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">matrix_dir</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="n">command</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">bash_exec</span><span class="p">,</span>
            <span class="n">matrix_path_str</span><span class="p">,</span>
            <span class="n">matrix_dir</span><span class="p">,</span>
            <span class="s1">&#39;--tree-path&#39;</span><span class="p">,</span>
            <span class="n">tree_path</span><span class="p">,</span>
            <span class="n">label_path_str</span><span class="p">,</span>
            <span class="n">label_path</span><span class="p">,</span>
            <span class="s1">&#39;--port&#39;</span><span class="p">,</span>
            <span class="n">port_str</span>
            <span class="p">]</span>

    <span class="n">command</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">command</span><span class="p">))</span>
    <span class="n">command</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>

    <span class="c1">#Run the command as if we were inside the</span>
    <span class="c1">#too-many-cells-interactive folder.</span>
    <span class="n">final_command</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(cd </span><span class="si">{</span><span class="n">path_to_tmc_interactive</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;&amp;&amp; </span><span class="si">{</span><span class="n">command</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="c1">#print(final_command)</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;localhost:&#39;</span> <span class="o">+</span> <span class="n">port_str</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Once the app is running, just type in &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;your browser </span><span class="se">\n</span><span class="s2">        </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
    <span class="n">txt</span><span class="o">=</span><span class="s2">&quot;The app will start loading after pressing Enter.&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
    <span class="n">pause</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Press Enter to continue ...&#39;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">final_command</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.write_cell_assignment_to_csv" class="doc doc-heading">
<code class="highlight language-python"><span class="n">write_cell_assignment_to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.write_cell_assignment_to_csv" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>This function creates a CSV file that indicates             the assignment of each cell to a specific             cluster. The first column is the cell id,             the second column is the cluster id, and             the third column is the path from the root             node to the given node.</p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">write_cell_assignment_to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function creates a CSV file that indicates \</span>
<span class="sd">        the assignment of each cell to a specific \</span>
<span class="sd">        cluster. The first column is the cell id, \</span>
<span class="sd">        the second column is the cluster id, and \</span>
<span class="sd">        the third column is the path from the root \</span>
<span class="sd">        node to the given node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;clusters.csv&#39;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sp_cluster&#39;</span><span class="p">,</span><span class="s1">&#39;sp_path&#39;</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">labels</span><span class="p">]</span>
    <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;sp_cluster&#39;</span><span class="p">:</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;sp_path&#39;</span><span class="p">:</span><span class="s1">&#39;path&#39;</span><span class="p">})</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="toomanycells.toomanycells.TooManyCells.write_cluster_list_to_json" class="doc doc-heading">
<code class="highlight language-python"><span class="n">write_cluster_list_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#toomanycells.toomanycells.TooManyCells.write_cluster_list_to_json" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>This function creates a JSON file that indicates             the assignment of each cell to a specific             cluster. </p>

        <details class="quote">
          <summary>Source code in <code>toomanycells/toomanycells.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">write_cluster_list_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function creates a JSON file that indicates \</span>
<span class="sd">        the assignment of each cell to a specific \</span>
<span class="sd">        cluster. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;cluster_list.json&#39;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">master_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">relevant_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">,</span> <span class="s2">&quot;sp_path&quot;</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">relevant_cols</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="s2">&quot;cell&quot;</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">,</span><span class="s2">&quot;cell&quot;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;sp_cluster&quot;</span><span class="p">]</span>
        <span class="n">path_str</span><span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;sp_path&quot;</span><span class="p">]</span>
        <span class="n">cell</span>    <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;cell&quot;</span><span class="p">]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">path_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
        <span class="n">list_of_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sub_dict_1</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;unCell&quot;</span><span class="p">:</span><span class="n">cell</span><span class="p">}</span>
        <span class="n">sub_dict_2</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;unRow&quot;</span><span class="p">:</span><span class="n">idx</span><span class="p">}</span>
        <span class="n">main_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_barcode&quot;</span><span class="p">:</span><span class="n">sub_dict_1</span><span class="p">,</span>
                     <span class="s2">&quot;_cellRow&quot;</span><span class="p">:</span><span class="n">sub_dict_2</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;unCluster&quot;</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="p">)}</span>
            <span class="n">list_of_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">master_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">main_dict</span><span class="p">,</span> <span class="n">list_of_nodes</span><span class="p">])</span>

    <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">master_list</span><span class="p">)</span>
    <span class="n">replace_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39; &#39;</span><span class="p">:</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">:</span><span class="s1">&#39;&quot;&#39;</span><span class="p">}</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">replace_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">regexp</span>  <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">replace_dict</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> 
    <span class="n">obj</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
        <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>







  </div>

    </div>

  </div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago"><span class="timeago" datetime="2024-07-30T19:38:43+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date">2024-07-30</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Created">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago"><span class="timeago" datetime="2024-07-30T19:38:43+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date">2024-07-30</span>
  </span>

    
    
    
  </aside>





                

              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2024 - 2024 Javier Ruiz-Ramirez
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.instant", "navigation.tracking", "navigation.top", "search.highlight", "search.share"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.fe8b6f2b.min.js"></script>
      
        <script src="../js/timeago.min.js"></script>
      
        <script src="../js/timeago_mkdocs_material.js"></script>
      
    
  </body>
</html>